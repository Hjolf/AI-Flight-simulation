using System;
using System.Collections;
using UnityEngine;
using CustomLibrary;
using System.Collections.Generic;
using System.IO;
using static GameBehaviour;
using static A320Pilot;


public class A320Systems : MonoBehaviour
{
    public static Rigidbody rb;
    static A320Pilot pilot;
    static A320Systems system;
    static AirportDatabase adb;

    public static GameBehaviour gb;

    float oldVelocity;
    float oldTurnrate;

    float averageAirspeedTimer;

    public enum PowerMode { Internal, Ground, APU, Engine };
    public enum LightType { Taxi, Turnoff, Takeoff, Nav, Strobe, Beacon, Land };
    public enum Side { Left, Right };
    public enum AltimeterSetting { Standard, pressure };
    public enum SteerMode { NoseWheel, Stabilizer };

    public bool startEnginesRunning = false;

    [Space(10)]
    public Transform posPoints;
    public Transform pivotPoint;
    public Transform frontPoint;

    [HideInInspector]
    public Vector2 vector2Pos;
    [HideInInspector]
    public Vector2 pivotPointV2;
    [HideInInspector]
    public Vector2 frontPointV2;

    [Space(10)]
    public float fuselageSpeed;
    public Vector3 fuselageVelocity;

    [Header("Basic specifications")]
    public string aircraftRegistration;
    public string aircraftManufacturer;
    public string aircraftModel;
    public string aircraftICAO;
    [Tooltip("Format: [short], [full]")]
    public string airline;
    public string engineType;

    [Header("Misc settings")]
    public float averageAirspeedTime;
    public float averageAirspeedFrequency;

    [Header("Autopilot")]
    public Autopilot autopilot;

    [Space(20)]

    public Transform centerOfMass;
    public Transform fuselage;
    public float emptyWeight;
    public float MTOW;
    [Range(0, 19900)]
    public float payload;
    [Range(0, 136)]
    public int pax;
    public float passengerAverageWeight;
    [Range(0, 27200)]
    public float fobLiters;
    public AltimeterSetting altimeterMode;
    public int altimeterSetting;
    public float maxRadioAltimeterDistance;
    public LayerMask radioAltimeterMask;
    public Transform radioAltimeterLocation;
    public float radioAltimeterHeightError;
    SmoothFloat realAltimeterSetting = new SmoothFloat(1013, new Vector2(950, 1050), 0.2f);

    [Header("Flight data")]
    public float groundSpeed;
    public float equivalentAirspeed;
    public float indicatedAirspeed;
    public float indicatedAirspeedAverage;
    List<float> indicatedAirSpeedList = new();
    public float trueAirspeed;
    public float cleanAirspeed;
    public float machSpeed;
    Vector3 relativeVelocity;
    Vector3 correctedRelativeVelocity;
    public OncomingFlow oncomingFlow;
    public float forwardAcceleration;
    public SmoothFloat smoothForwardAcceleration = new SmoothFloat(0, new Vector2(-1000, 1000), 4.0f);
    public float radioAltimeter;
    public float indicatedAltitude;
    public int currentFlightLevel;
    public float trueAltitude;
    public float rateOfClimb;
    public float fuselageAngleOfAttack;
    public float fuselageSideSlip;
    public float correctedSideSlip;
    public float noseAttitude;
    public float noseAttitudeChange;
    public float trueFlightPathAngle;
    public float rollAngle;
    public float rollSpeed;
    public float heading;
    [HideInInspector]
    public float track;
    public float turnrate;
    public float yawrate;
    public float airframeLoadFactor;
    public float totalAirframeDrag;
    public float totalAirframeLift;
    public float maxCurrentClimbSpeed;
    public MCDU mCDU;

    public Coordinates coordinatePosition;

    [Header("Surrounding conditions")]
    public WeatherCondition affectingWeather;

    [Header("Engines")]
    public Engine[] engines;
    public float totalEngineThrust;
    Vector3 engineSoundPosition;

    [Header("Gear")]
    public float minAntiSkidSpeed = 20;
    public MainGear[] mainGear;
    public FrontGear frontGear;

    float wheelBrake;

    [Space(10)]
    public AdvancedAudio tireSkidSound;
    public float tireSkidLimit;
    public AnimationCurve tireSkidVolumeCurve;
    public AnimationCurve tireSkidPitchCurve;

    [Header("Lights")]
    public AircraftLight taxiLight;
    public AircraftLight takeoffLight;
    public AircraftLight turnoffLights;
    public AircraftLight beaconLight;
    public AircraftLight navLight;
    public AircraftLight strobeLight;
    public AircraftLight landLight;
    public LandLightComponent[] landLightObject;

    [Header("APU")]
    public APU apu;

    [Header("Control surfaces")]
    public Wing[] wings;
    public HorizontalStabilizer[] horizontalStabilizers;
    public VerticalStabilizer verticalStabilizer;

    [Header("Switches & buttons")]
    [Range(-1, 2)]
    public int spoilerSwitch = 0;
    [Range(0, 4)]
    public int flapsSwitch = 0;

    [Space(15)]
    public Transform skidmark;

    [Space(20)]
    public AnimationCurve modifiedSin;

    [Header("Stats")]
    public bool batteriesOn = false;
    public PowerMode powerMode;
    public SmoothFloat powerSupply = new SmoothFloat(0, new Vector2(0, 1), 0.1f);
    public bool anyEnginesReady = false;
    public bool antiSkid = false;
    public SteerMode steerMode;
    public bool onGround = false;
    bool onGroundTest = false;
    public bool mainOnGround = false;
    bool mainOnGroundTest = false;
    public bool frontOnGround = false;
    bool frontOnGroundTest = false;

    float onGroundTimer;
    float mainOnGroundTimer;
    float frontOnGroundTimer;

    [Space(10)]
    public bool gearDown;
    public bool gearRetracting;
    public float totalTireSlip;

    [Space(10)]
    public bool taxiLightOn = false;
    public bool takeoffLightOn = false;
    public bool turnoffLightsOn = false;
    public bool beaconLightOn = false;
    public bool navLightOn = false;
    public bool strobeLightOn = false;
    public bool landLightOn = false;


    [Serializable]
    public class OncomingFlow
    {
        public float direction;
        public float velocity;

        
        public void Update(float _direction, float _velocity)
        {
            direction = _direction;
            velocity = _velocity;
        }

        public OncomingFlow GetOncomingFlow(WeatherCondition conditions, AnimationCurve modSin)
        {
            OncomingFlow flow = new();

            flow.direction = Vector3.Angle(rb.velocity.normalized, new Vector3(conditions.windVelocity.x, 0, conditions.windVelocity.y).normalized);
            flow.direction = -((flow.direction > 180) ? flow.direction - 360 : flow.direction);
            flow.velocity = (1 - modSin.Evaluate(Mathf.Abs(flow.direction) * Mathf.Deg2Rad)) * conditions.windSpeed;

            return flow;
        }

        public OncomingFlow GetCleanOncomingFlow(WeatherCondition conditions, AnimationCurve modSin)
        {
            OncomingFlow flow = new();

            flow.direction = Vector3.Angle(rb.velocity.normalized, new Vector3(conditions.cleanWindVelocity.x, 0, conditions.cleanWindVelocity.y).normalized);
            flow.direction = -((flow.direction > 180) ? flow.direction - 360 : flow.direction);
            flow.velocity = (1 - modSin.Evaluate(Mathf.Abs(flow.direction) * Mathf.Deg2Rad)) * conditions.cleanWindSpeed;

            return flow;
        }
    }

    [Serializable]
    public class Autopilot
    {
        GameBehaviour gb;
        AirportDatabase adb;

        public bool autopilotOn = false;

        public enum SpeedMode { Mach, Knots };
        public SpeedMode speedMode;

        public bool localizerActive = false;
        public bool localizerCaptured = false;
        public bool glideslopeActive = false;
        public bool glideslopeCaptured = false;

        public FlightWaypoint waypointDirect;

        public float altitude;
        public float speed;
        public float heading;


        public void Init(GameBehaviour gb, AirportDatabase adb)
        {
            this.gb = gb;
            this.adb = adb;
        }

        public void Update()
        {
            if (localizerActive)
            {
                if(system.mCDU.planPage.arrivalRunway.GetLocalizerDistance() <= 4500 && system.mCDU.planPage.arrivalRunway.GetLocalizerPointAngle() <= 10 && Mathf.Abs(system.mCDU.planPage.arrivalRunway.GetLocalizerError()) <= 45 && !localizerCaptured)
                {
                    Debug.Log("Localizer captured");
                    localizerCaptured = true;
                    pilot.hdgControl = HeadingControlSetting.LOC;
                }
            }

            if (glideslopeActive)
            {
                if (system.mCDU.planPage.arrivalRunway.GetGlideslopeDiff() > -0.05f && !glideslopeCaptured && localizerCaptured)
                {
                    Debug.Log("Glideslope captured");
                    glideslopeCaptured = true;
                    pilot.altControl = AltitudeControlSetting.GS;
                }
            }
        }

        public void DirectToWaypoint(FlightWaypoint waypoint)
        {
            waypointDirect = waypoint;
            pilot.hdgControl = HeadingControlSetting.Direct;
        }


        public void DirectToWaypoint(string waypointName)
        {
            foreach(FlightWaypoint wp in adb.waypoints)
            {
                if(wp.point.designation == waypointName)
                {
                    waypointDirect = wp;
                    break;
                }
            }

            pilot.hdgControl = HeadingControlSetting.Direct;
        }

        public void FlyFlightPlan()
        {
            pilot.hdgControl = HeadingControlSetting.FlightPlan;
            system.mCDU.planPage.FlyFlightPlan();
        }

        public void LocActive(bool active)
        {
            localizerActive = active;
        }

        public void GSActive(bool active)
        {
            glideslopeActive = active;
        }

        public void ApproachActive(bool active)
        {
            localizerActive = active;
            glideslopeActive = active;
        }

        public void SetCruiseSpeed()
        {
            speedMode = SpeedMode.Knots;
            speed = 310;
        }

        public float ShortestAngle(float start, float target)
        {
            float modDiff = (target - start) % (Mathf.PI * 2);
            float shortestDistance = Mathf.PI - Mathf.Abs(Mathf.Abs(modDiff) - Mathf.PI);
            return (modDiff + (Mathf.PI * 2)) % (Mathf.PI * 2) < Mathf.PI ? shortestDistance *= 1 : shortestDistance *= -1;
        }
    }
    [Serializable]
    public class MCDU
    {
        [Serializable]
        public class DirPage
        {
            public DirPage()
            {
                
            }

            public void Clear()
            {
                
            }
        }

        [Serializable]
        public class ProgPage
        {
            public ProgPage()
            {

            }

            public void Clear()
            {

            }
        }

        [Serializable]
        public class PerfPage
        {
            public Takeoff takeoff;
            public Climb climb;
            public Cruise cruise;
            public Descent descent;
            public Approach approach;

            [Serializable]
            public class Takeoff
            {
                public int v1Speed;
                public int vrSpeed;
                public int v2Speed;
                public int transAlt;
                public int thrustRedAlt;
                public int accAlt;
                public string rwy;
                public int flapsSetting;
                public float trimSetting;
                public int flexTemp;
                public int engOutAcc;

                public Takeoff(int _v1Speed, int _vrSpeed, int _v2Speed, int _transAlt, int _thrustRedAlt, int _accAlt, string _rwy, int _flapsSetting, float _trimSetting, int _flexTemp, int _engOutAcc)
                {
                    v1Speed = _v1Speed;
                    vrSpeed = _vrSpeed;
                    v2Speed = _v2Speed;
                    transAlt = _transAlt;
                    thrustRedAlt = _thrustRedAlt;
                    accAlt = _accAlt;
                    rwy = _rwy;
                    flapsSetting = _flapsSetting;
                    trimSetting = _trimSetting;
                    flexTemp = _flexTemp;
                    engOutAcc = _engOutAcc;
                }

                public void Clear()
                {
                    v1Speed = 0;
                    vrSpeed = 0;
                    v2Speed = 0;
                    transAlt = 0;
                    thrustRedAlt = 0;
                    accAlt = 0;
                    rwy = "";
                    flapsSetting = 0;
                    trimSetting = 0;
                    flexTemp = 0;
                    engOutAcc = 0;
                }
            }

            [Serializable]
            public class Climb
            {
                

                public Climb()
                {
                    
                }

                public void Clear()
                {
                    
                }
            }

            [Serializable]
            public class Cruise
            {


                public Cruise()
                {

                }

                public void Clear()
                {

                }
            }

            [Serializable]
            public class Descent
            {


                public Descent()
                {

                }

                public void Clear()
                {

                }
            }

            [Serializable]
            public class Approach
            {
                public float destQnh;
                public float temp;
                public MagWind magWind;
                public int transAlt;
                public int vapp;
                public int vls = 133;
                public int flpRetr = 160;
                public int sltRetr = 192;
                public int clean = 212;
                public int mda;
                public int dh;
                public int flapSetting;


                [Serializable]
                public struct MagWind
                {
                    public float direction;
                    public float speed;

                    public MagWind(float direction, float speed)
                    {
                        this.direction = direction;
                        this.speed = speed;
                    }
                }

                public Approach(float destQnh, float temp, MagWind magWind, int transAlt, int vapp, int mda, int dh, int flapSetting)
                {
                    this.destQnh = destQnh;
                    this.temp = temp;
                    this.magWind = magWind;
                    this.transAlt = transAlt;
                    this.vapp = vapp;
                    this.mda = mda;
                    this.dh = dh;
                    this.flapSetting = flapSetting;
                }

                public void Clear()
                {
                    destQnh = 0;
                    temp = 0;
                    magWind = new MagWind(0, 0);
                    transAlt = 0;
                    vapp = 0;
                    mda = 0;
                    dh = 0;
                    flapSetting = 0;
                }

                public int GetDecisionAltitude()
                {
                    if(mda != 0)
                    {
                        return mda;
                    }
                    else if(dh != 0)
                    {
                        return dh;
                    }

                    return 0;
                }
            }

            public PerfPage()
            {

            }

            public void Clear()
            {
                takeoff.Clear();
            }
        }

        [Serializable]
        public class InitPage
        {
            public string fromICAO;
            public string toICAO;
            public string flightNumber;
            public int costIndex;
            public int cruiseFL;

            public InitPage(string _fromICAO, string _toICAO, string _flightNumber, int _costIndex, int _cruiseFL)
            {
                fromICAO = _fromICAO;
                toICAO = _toICAO;
                flightNumber = _flightNumber;
                costIndex = _costIndex;
                cruiseFL = _cruiseFL;
            }
            public void Clear()
            {
                fromICAO = "";
                toICAO = "";
                flightNumber = "";
                costIndex = 0;
                cruiseFL = 0;
            }
        }

        [Serializable]
        public class DataPage
        {
            public DataPage()
            {

            }

            public void Clear()
            {

            }
        }

        [Serializable]
        public class FPlanPage
        {
            [Header("Main flightplan")]
            public List<FlightWaypoint> waypointsToFollowCached = new();
            public Waypoint departureRunwayWaypoint;
            public Waypoint arrivalRunwayWaypoint;
            public List<FlightWaypointData> waypoints = new();
            public DepartureRunwayData departureRunway;
            public ArrivalRunwayData arrivalRunway;
            public List<FlightTurnSegment> segments = new();

            [Header("Stats")]
            public float distanceToWaypoint;
            public int currentWaypointIndex;
            public float totalDistanceCovered;


            [Serializable]
            public class FlightWaypointData
            {
                public AirportDatabase.FlightWaypointRef waypoint;
                public FlightTurnSegment connectedSegment;
                public Vector3 pointDirection;


                public FlightWaypointData(AirportDatabase.FlightWaypointRef waypoint)
                {
                    this.waypoint = waypoint;
                    connectedSegment = null;
                }

                public FlightWaypointData(AirportDatabase.FlightWaypointRef waypoint, Vector3 pointDirection)
                {
                    this.waypoint = waypoint;
                    this.pointDirection = pointDirection;
                    this.pointDirection.y = 0;
                }

                public FlightWaypointData(AirportDatabase.FlightWaypointRef waypoint, FlightTurnSegment connectedSegment)
                {
                    this.waypoint = waypoint;
                    this.connectedSegment = connectedSegment;
                }

                public void AddToSegment(FlightTurnSegment segment)
                {
                    connectedSegment = segment;
                }
            }

            [Serializable]
            public class DepartureRunwayData
            {
                public FlightWaypointData runway;
                public AirportDatabase.Airport.Runway.RunwayEnd.STAR sid;
                public FlightTurnSegment connectedSegment;


                public DepartureRunwayData(FlightWaypointData waypoint)
                {
                    runway = waypoint;
                    connectedSegment = null;
                }

                public DepartureRunwayData(FlightWaypointData waypoint, FlightTurnSegment connectedSegment)
                {
                    runway = waypoint;
                    this.connectedSegment = connectedSegment;
                }

                public void AddToSegment(FlightTurnSegment segment)
                {
                    connectedSegment = segment;
                }
            }

            [Serializable]
            public class ArrivalRunwayData
            {
                public FlightWaypointData runway;
                public Waypoint waypoint;
                public AirportDatabase.Airport.Runway.RunwayEnd.STAR star;
                public FlightTurnSegment connectedSegment;


                public ArrivalRunwayData(FlightWaypointData runway, Waypoint waypoint)
                {
                    this.runway = runway;
                    this.waypoint = waypoint;
                    connectedSegment = null;
                }

                public ArrivalRunwayData(FlightWaypointData waypoint, FlightTurnSegment connectedSegment)
                {
                    runway = waypoint;
                    this.connectedSegment = connectedSegment;
                }

                public void AddToSegment(FlightTurnSegment segment)
                {
                    connectedSegment = segment;
                }

                public float GetLocalizerError()
                {
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, runway.pointDirection, system.pivotPoint.transform.position);
                    nearestPoint.y = system.pivotPoint.transform.position.y;
                    Vector3 correctedPoint = nearestPoint + runway.pointDirection * (pilot.flightSegmentCorrectionDistance + Vector3.Distance(system.pivotPoint.transform.position, nearestPoint));
                    Vector2 pointV = new Vector2(correctedPoint.x, correctedPoint.z);
                    Vector3 normalizedVelocity = rb.velocity.normalized;
                    float flightAngle = Vector2.SignedAngle(new Vector2(normalizedVelocity.x, normalizedVelocity.z), (pointV - system.pivotPointV2).normalized);

                    if (system.autopilot.localizerCaptured)
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.green);
                    }
                    else
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.white);
                    }

                    return flightAngle;
                }

                public float GetLocalizerPointAngle()
                {
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, runway.pointDirection, system.pivotPoint.transform.position);
                    nearestPoint.y = 0;
                    float angle = PointAngleDiff(runway.waypoint.position, nearestPoint, system.pivotPoint.transform.position);

                    return angle * Mathf.Rad2Deg;
                }

                public float GetLocalizerDistance()
                {
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, runway.pointDirection, system.pivotPoint.transform.position);
                    Vector2 targetPointV2 = new Vector2(nearestPoint.x, nearestPoint.z);
                    float distance = Vector2.Distance(system.pivotPointV2, targetPointV2);

                    return distance;
                }

                public float GetGlideslopeError()
                {
                    Vector3 glideslopeDirection = Quaternion.AngleAxis(3, Vector3.right) * -runway.pointDirection;
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, -glideslopeDirection, system.pivotPoint.transform.position);
                    Vector3 correctedPoint = nearestPoint + -glideslopeDirection * pilot.flightSegmentCorrectionDistance;
                    float currentGlide = Mathf.Asin((system.pivotPoint.transform.position.y - runway.waypoint.position.y) / Vector3.Distance(runway.waypoint.position, system.pivotPoint.transform.position)) * Mathf.Rad2Deg;
                    float error = currentGlide - 3;

                    if (system.autopilot.glideslopeCaptured)
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.blue);
                    }
                    else
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.white);
                    }

                    Debug.DrawRay(runway.waypoint.position, glideslopeDirection * 15000, Color.blue);

                    return error;
                }

                public float GetGlideslopeAltitude()
                {
                    Vector3 glideslopeDirection = Quaternion.AngleAxis(3, Vector3.right) * -runway.pointDirection;
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, -glideslopeDirection, system.pivotPoint.transform.position);
                    Vector3 correctedPoint = nearestPoint + -glideslopeDirection * pilot.flightSegmentCorrectionDistance;
                    float gsAltitude = correctedPoint.y * metersToFeet;

                    return gsAltitude;
                }

                public float GetGlideslopeDiff()
                {
                    Vector3 glideslopeDirection = Quaternion.AngleAxis(3, Vector3.right) * -runway.pointDirection;
                    Vector3 nearestPoint = NearestPointOnLine(runway.waypoint.position, -glideslopeDirection, system.pivotPoint.transform.position);
                    Vector3 correctedPoint = nearestPoint + -glideslopeDirection * pilot.flightSegmentCorrectionDistance;
                    float currentGlide = Mathf.Asin((system.pivotPoint.transform.position.y - runway.waypoint.position.y) / Vector3.Distance(runway.waypoint.position, system.pivotPoint.transform.position)) * Mathf.Rad2Deg;
                    float error = currentGlide - 3;

                    if (system.autopilot.glideslopeCaptured)
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.blue);
                    }
                    else
                    {
                        Debug.DrawLine(system.pivotPoint.transform.position, correctedPoint, Color.white);
                    }

                    Debug.DrawRay(runway.waypoint.position, glideslopeDirection * 15000, Color.blue);

                    return error;
                }

                public float DistanceToTouchdown()
                {
                    return Vector3.Distance(system.pivotPoint.transform.position, runway.waypoint.position) * metersToNauticalMiles;
                }
            }

            [Serializable]
            public class FlightSegment
            {
                public AirportDatabase.FlightWaypointRef from;
                public AirportDatabase.FlightWaypointRef to;


                public FlightSegment(AirportDatabase.FlightWaypointRef from, AirportDatabase.FlightWaypointRef to)
                {
                    this.from = from;
                    this.to = to;
                }
            }

            [Serializable]
            public class FlightTurnSegment
            {
                public AirportDatabase.FlightWaypointRef from;
                public AirportDatabase.FlightWaypointRef anglePoint;
                public AirportDatabase.FlightWaypointRef to;
                public FlightSegment startSegment;
                public FlightSegment endSegment;

                public bool hasTurn = false;

                public float sweepAngle;
                public float turnRadius;

                public Vector3 fromPos;
                public Vector3 anglePos;
                public Vector3 toPos;

                [Header("Turn vectors")]
                public Vector3[] turnPoints;

                public Vector3 c1;
                public Vector3 c2;
                public Vector3 pc;

                public float stAngle;
                public float endAngle;


                public FlightTurnSegment(AirportDatabase.FlightWaypointRef from, AirportDatabase.FlightWaypointRef anglePoint, AirportDatabase.FlightWaypointRef to)
                {
                    this.from = from;
                    this.anglePoint = anglePoint;
                    this.to = to;

                    startSegment = new FlightSegment(from, anglePoint);
                    endSegment = new FlightSegment(anglePoint, to);
                }

                public void AddTurnData(Vector3[] turnPoints, float sweepAngle, float turnRadius, Vector3 pc, Vector3 c1, Vector3 c2, Vector3 fromPos, Vector3 anglePos, Vector3 toPos, float stAngle, float endAngle)
                {
                    this.turnPoints = turnPoints;
                    this.sweepAngle = sweepAngle;
                    this.turnRadius = turnRadius;
                    this.pc = pc;
                    this.c1 = c1;
                    this.c2 = c2;
                    this.fromPos = fromPos;
                    this.anglePos = anglePos;
                    this.toPos = toPos;
                    this.stAngle = stAngle;
                    this.endAngle = endAngle;

                    hasTurn = true;
                }

                public float ShortestAngle(float start, float target)
                {
                    float modDiff = (target - start) % (Mathf.PI * 2);
                    float shortestDistance = Mathf.PI - Mathf.Abs(Mathf.Abs(modDiff) - Mathf.PI);
                    return (modDiff + (Mathf.PI * 2)) % (Mathf.PI * 2) < Mathf.PI ? shortestDistance *= 1 : shortestDistance *= -1;
                }

                public int GetTurnDirection()
                {
                    return (int)Mathf.Sign(-ShortestAngle(stAngle, endAngle));
                }
                
                public int GetTurnSigned()
                {
                    float diff = ((Mathf.PI + stAngle) - (Mathf.PI + endAngle)) % (Mathf.PI * 2);

                    if (diff > Mathf.PI)
                    {
                        diff = -((Mathf.PI * 2) - diff);
                    }

                    return (int)Mathf.Sign(diff);
                }
            }

            public FPlanPage()
            {

            }

            public void Update()
            {
                distanceToWaypoint = Mathf.Sqrt(Mathf.Pow(waypoints[currentWaypointIndex].waypoint.position.x - system.transform.position.x, 2) + Mathf.Pow(waypoints[currentWaypointIndex].waypoint.position.z - system.transform.position.z, 2)) * metersToNauticalMiles;
            }

            public void Clear()
            {
                waypoints = null;
            }

            public Vector3 GetDescentPoint(MCDU _ref, float altitude)
            {
                float distance = (altitude * 300) / 1000;

                float currentDistance = 0;
                for(int i = segments.Count - 1; i > -1; i--)
                {
                    float[] lengths = new float[3];

                    if(i == segments.Count - 1)
                    {
                        lengths[0] = Mathf.Sqrt(Mathf.Pow(segments[i].toPos.x - segments[i].c2.x, 2) + Mathf.Pow(segments[i].toPos.z - segments[i].c2.z, 2)) * metersToNauticalMiles;
                        lengths[1] = Mathf.Abs(segments[i].sweepAngle) * segments[i].turnRadius * metersToNauticalMiles;
                    }
                    else if(i < segments.Count - 1 && i > 0)
                    {
                        lengths[0] = Mathf.Sqrt(Mathf.Pow(segments[i + 1].c1.x - segments[i].c2.x, 2) + Mathf.Pow(segments[i + 1].c1.z - segments[i].c2.z, 2)) * metersToNauticalMiles;
                        lengths[1] = Mathf.Abs(segments[i].sweepAngle) * segments[i].turnRadius * metersToNauticalMiles;
                    }
                    else if(i == 0)
                    {
                        lengths[0] = Mathf.Sqrt(Mathf.Pow(segments[i + 1].c1.x - segments[i].c2.x, 2) + Mathf.Pow(segments[i + 1].c1.z - segments[i].c2.z, 2)) * metersToNauticalMiles;
                        lengths[1] = Mathf.Abs(segments[i].sweepAngle) * segments[i].turnRadius * metersToNauticalMiles;
                        lengths[2] = Mathf.Sqrt(Mathf.Pow(segments[i].c1.x - segments[i].fromPos.x, 2) + Mathf.Pow(segments[i].c1.z - segments[i].fromPos.z, 2)) * metersToNauticalMiles;
                    }

                    for (int ii = 0; ii < lengths.Length; ii++)
                    {
                        currentDistance += lengths[ii];

                        if(distance <= currentDistance)
                        {
                            float progress = (distance - (currentDistance - lengths[ii])) / metersToNauticalMiles;

                            if (ii == 0)
                            {
                                if (i == segments.Count - 1)
                                {
                                    Vector3 direction = (segments[i].c2 - segments[i].toPos).normalized;
                                    return segments[i].toPos + direction * progress;
                                }
                                else if (i < segments.Count - 1)
                                {
                                    Vector3 direction = (segments[i].anglePos - segments[i + 1].c1).normalized;
                                    return segments[i + 1].c1 + direction * progress;
                                }
                            }
                            else if(ii == 1)
                            {
                                float angleDiff = -segments[i].GetTurnSigned() * (progress / Mathf.Abs(segments[i].sweepAngle * segments[i].turnRadius)) * segments[i].sweepAngle;
                                float pointX = (float)(segments[i].pc.x + Mathf.Cos(segments[i].endAngle - angleDiff) * segments[i].turnRadius);
                                float pointY = (float)(segments[i].pc.z + Mathf.Sin(segments[i].endAngle - angleDiff) * segments[i].turnRadius);
                                return new Vector3(pointX, 0, pointY);
                            }
                            if (ii == 2)
                            {
                                Vector3 direction = (segments[i].fromPos - segments[i].anglePos).normalized;
                                return segments[i].c1 + direction * progress;
                            }
                        }
                    }
                }

                Debug.LogWarning("Flight path too short for descent");
                return Vector3.zero;
            }

            public void AddFlightPlan(GameBehaviour gb, Waypoint departureRunwayWaypoint, Waypoint arrivalRunwayWaypoint, List<FlightWaypoint> waypoints)
            {
                float radius = 0;
                float segment = 0;
                totalDistanceCovered = 0;

                List<FlightWaypoint> waypoints_cache = new();
                waypoints_cache.AddRange(waypoints);

                this.waypoints.Clear();
                // 3Nm straight departure
                Vector3 waypointPosition = new Vector3(departureRunwayWaypoint.transform.position.x, 0, departureRunwayWaypoint.transform.position.z) + (departureRunwayWaypoint.touchdownPointDir * (3 / metersToNauticalMiles));

                AirportDatabase.FlightWaypointRef departureWaypointRef = new AirportDatabase.FlightWaypointRef("runway_" + departureRunwayWaypoint.designation, departureRunwayWaypoint.touchdownPoint, gb);
                AirportDatabase.FlightWaypointRef departureWaypointRef2 = new AirportDatabase.FlightWaypointRef("departure_point", waypointPosition, gb);
                this.waypoints.Add(new FlightWaypointData(departureWaypointRef, departureRunwayWaypoint.touchdownPointDir));
                this.waypoints.Add(new FlightWaypointData(departureWaypointRef2, (waypointPosition - departureRunwayWaypoint.touchdownPoint).normalized));
                
                segments.Clear();
                for(int x = 0; x < waypoints_cache.Count; x++)
                {
                    waypoints_cache[x].point.position.y = 0;

                    if(x == 0)
                    {
                        if(waypoints_cache.Count > 1)
                        {
                            AirportDatabase.FlightWaypointRef waypointRef = new AirportDatabase.FlightWaypointRef(waypoints_cache[0].point.designation, waypoints_cache[0].point.position, gb);
                            this.waypoints.Add(new FlightWaypointData(waypointRef, (waypoints_cache[0].point.position - waypointPosition).normalized));
                        }
                    }
                    else
                    {
                        AirportDatabase.FlightWaypointRef waypointRef = new AirportDatabase.FlightWaypointRef(waypoints_cache[x].point.designation, waypoints_cache[x].point.position, gb);
                        this.waypoints.Add(new FlightWaypointData(waypointRef, (waypoints_cache[x].point.position - waypoints_cache[x - 1].point.position).normalized));
                    }
                }

                // 3Nm straight final
                waypointPosition = new Vector3(arrivalRunwayWaypoint.transform.position.x, 0, arrivalRunwayWaypoint.transform.position.z) - (arrivalRunwayWaypoint.touchdownPointDir * (3 / metersToNauticalMiles));

                AirportDatabase.FlightWaypointRef arrivalWaypointRef = new AirportDatabase.FlightWaypointRef("arrival_point", waypointPosition, gb);
                AirportDatabase.FlightWaypointRef arrivalWaypointRef2 = new AirportDatabase.FlightWaypointRef("runway_" + arrivalRunwayWaypoint.designation, arrivalRunwayWaypoint.touchdownPoint, gb);
                this.waypoints.Add(new FlightWaypointData(arrivalWaypointRef, (waypointPosition - waypoints_cache[waypoints_cache.Count - 1].point.position).normalized));
                this.waypoints.Add(new FlightWaypointData(arrivalWaypointRef2, arrivalRunwayWaypoint.touchdownPointDir));
                arrivalRunway = new ArrivalRunwayData(this.waypoints[this.waypoints.Count - 1], arrivalRunwayWaypoint);

                for (int i = 0; i < this.waypoints.Count; i++)
                {
                    if(i < this.waypoints.Count - 2)
                    {
                        segments.Add(new FlightTurnSegment(this.waypoints[i].waypoint, this.waypoints[i + 1].waypoint, this.waypoints[i + 2].waypoint));
                        this.waypoints[i + 1].AddToSegment(segments[i]);
                    }
                }

                if (segments.Count > 0)
                {
                    for (int c = 0; c < segments.Count; c++)
                    {
                        CalculateTurn(c, radius, segment);
                        if(c < segments.Count - 1)
                        {
                            totalDistanceCovered += Mathf.Abs(segments[c].sweepAngle) / Mathf.PI * segments[c].turnRadius * metersToNauticalMiles;
                            totalDistanceCovered += Mathf.Sqrt(Mathf.Pow(segments[c].fromPos.x - segments[c].c1.x, 2) + Mathf.Pow(segments[c].fromPos.z - segments[c].c1.z, 2)) * metersToNauticalMiles;
                        }
                        else if(c == segments.Count - 1)
                        {
                            totalDistanceCovered += Mathf.Abs(segments[c].sweepAngle) / Mathf.PI * segments[c].turnRadius * metersToNauticalMiles;
                            totalDistanceCovered += Mathf.Sqrt(Mathf.Pow(segments[c].fromPos.x - segments[c].c1.x, 2) + Mathf.Pow(segments[c].fromPos.z - segments[c].c1.z, 2)) * metersToNauticalMiles;
                            totalDistanceCovered += Mathf.Sqrt(Mathf.Pow(segments[c].c2.x - segments[c].toPos.x, 2) + Mathf.Pow(segments[c].c2.z - segments[c].toPos.z, 2)) * metersToNauticalMiles;
                        }
                    }
                }
            }

            public void FlyFlightPlan()
            {
                if (waypoints.Count > 0)
                {
                    currentWaypointIndex = 0;
                }
                else
                {
                    Debug.LogWarning("Can't fly flight plan, no waypoints set");
                }
            }

            public void DirectTo()
            {
                if(waypoints.Count > 0)
                {
                    float radius = 0;
                    float segment = 0;

                    // Give 0.8 nautical miles of straight line to start
                    Vector3 waypointPosition = system.transform.position + (rb.velocity.normalized * (0.8f / metersToNauticalMiles));

                    List<FlightWaypointData> waypoints_cache = new();
                    waypoints_cache.AddRange(waypoints);
                    waypoints.Clear();
                    segments.Clear();

                    AirportDatabase.FlightWaypointRef waypointRef = new AirportDatabase.FlightWaypointRef("merging_point", waypointPosition, gb);
                    waypoints.Add(new FlightWaypointData(waypointRef, (waypoints_cache[0].waypoint.position - waypointPosition).normalized));

                    for (int x = 0; x < waypoints_cache.Count; x++)
                    {
                        if (x == 0)
                        {
                            if (waypoints_cache.Count > 1)
                            {
                                AirportDatabase.FlightWaypointRef wp = new AirportDatabase.FlightWaypointRef(waypoints_cache[0].waypoint.designation, waypoints_cache[0].waypoint.position, gb);
                                waypoints.Add(new FlightWaypointData(wp, (waypoints_cache[0].waypoint.position - waypointPosition).normalized));
                            }
                        }
                        else if(x > 0 && x < waypoints_cache.Count - 1)
                        {
                            AirportDatabase.FlightWaypointRef wp = new AirportDatabase.FlightWaypointRef(waypoints_cache[x].waypoint.designation, waypoints_cache[x].waypoint.position, gb);
                            waypoints.Add(new FlightWaypointData(wp, (waypoints_cache[x].waypoint.position - waypoints_cache[x - 1].waypoint.position).normalized));
                        }
                        else if(x == waypoints_cache.Count - 1)
                        {
                            AirportDatabase.FlightWaypointRef wp = new AirportDatabase.FlightWaypointRef(waypoints_cache[x].waypoint.designation, waypoints_cache[x].waypoint.position, gb);
                            waypoints.Add(new FlightWaypointData(wp, (waypoints_cache[x].waypoint.position - waypoints_cache[x - 1].waypoint.position).normalized));

                        }
                    }

                    // 5Nm straight final
                    waypointPosition = arrivalRunwayWaypoint.transform.position - (arrivalRunwayWaypoint.touchdownPointDir * (5 / metersToNauticalMiles));

                    AirportDatabase.FlightWaypointRef arrivalWaypointRef = new AirportDatabase.FlightWaypointRef("arrival_point", arrivalRunwayWaypoint.touchdownPoint, gb);
                    AirportDatabase.FlightWaypointRef arrivalWaypointRef2 = new AirportDatabase.FlightWaypointRef("runway_" + arrivalRunwayWaypoint.designation, waypointPosition, gb);
                    this.waypoints.Add(new FlightWaypointData(arrivalWaypointRef, departureRunwayWaypoint.touchdownPointDir));
                    this.waypoints.Add(new FlightWaypointData(arrivalWaypointRef2, departureRunwayWaypoint.touchdownPointDir));

                    for (int i = 0; i < waypoints.Count; i++)
                    {
                        if (i < waypoints.Count - 2)
                        {
                            segments.Add(new FlightTurnSegment(waypoints[i].waypoint, waypoints[i + 1].waypoint, waypoints[i + 2].waypoint));
                            //waypoints[i].AddToSegment(segments[i]);
                            waypoints[i + 1].AddToSegment(segments[i]);
                            //waypoints[i + 2].AddToSegment(segments[i]);
                        }
                    }

                    if (segments.Count > 0)
                    {
                        for (int c = 0; c < segments.Count; c++)
                        {
                            CalculateTurn(c, radius, segment);
                        }
                    }
                }
                else
                {
                    Debug.LogWarning("Can't continue flight plan, no waypoints set");
                }
            }

            void CalculateTurn(int c, float radius, float segment)
            {
                Vector3 anglePointPos = new Vector3(segments[c].anglePoint.position.x, 0, segments[c].anglePoint.position.z);
                Vector3 fromPos = new Vector3(segments[c].from.position.x, 0, segments[c].from.position.z);
                Vector3 toPos = new Vector3(segments[c].to.position.x, 0, segments[c].to.position.z);

                float cornerRadius = Mathf.Pow(250, 2) / (Mathf.Abs(Physics.gravity.y) * Mathf.Tan(30 * Mathf.Deg2Rad)) / metersToFeet * 1.25f;

                /*
                if (PointAngleDiff(anglePointPos, fromPos, toPos) < Mathf.PI)
                {
                    Debug.LogWarning("PointAngleDiff over Mathf.PI, returning");
                    return;
                }
                */

                float pp1 = Vector3.Distance(anglePointPos, fromPos);
                float pp2 = Vector3.Distance(anglePointPos, toPos);

                float minSeg = Mathf.Min(pp1, pp2);

                float angle = TriangleAngle(anglePointPos, fromPos, toPos);

                float seg = cornerRadius / Mathf.Abs(Mathf.Tan((Mathf.Deg2Rad * angle) / 2));

                if (seg > minSeg)
                {
                    segment = minSeg;
                    radius = segment * Mathf.Abs(Mathf.Tan((Mathf.Deg2Rad * angle) / 2));
                }
                else
                {
                    segment = seg;
                    radius = cornerRadius;
                }

                Vector3 p1Dir = (fromPos - anglePointPos).normalized;
                Vector3 p2Dir = (toPos - anglePointPos).normalized;

                float po = Mathf.Sqrt(Mathf.Pow(radius, 2) + Mathf.Pow(segment, 2));

                Vector3 c1 = anglePointPos + p1Dir * segment;
                Vector3 c2 = anglePointPos + p2Dir * segment;
                Vector3 pc = anglePointPos + (p1Dir + p2Dir).normalized * po;

                float st = Mathf.Atan2(c1.z - pc.z, c1.x - pc.x);
                float end = Mathf.Atan2(c2.z - pc.z, c2.x - pc.x);

                float startAngle = st;
                float endAngle = end;

                float sweepAngle = endAngle - startAngle;
                Vector3 lastPoint = c2;
                bool lessThanZero = false;

                if (sweepAngle < 0)
                {
                    startAngle = endAngle;
                    sweepAngle = -sweepAngle;
                    lastPoint = c1;

                    lessThanZero = true;
                }

                if (sweepAngle > Mathf.PI)
                {
                    if (lessThanZero)
                    {
                        sweepAngle = -(end + (Mathf.PI + (Mathf.PI - st)));
                    }
                    else
                    {
                        sweepAngle = end + (-(Mathf.PI * 2) - st);
                    }
                }

                int points = (int)((radius * (180 - angle)) / 2000);
                if (points > 1000 || points < 0)
                {
                    points = 0;
                }
                Vector3[] pointList = new Vector3[points + 1];

                for (int i = 0; i < points; i++)
                {
                    float pointX = (float)(pc.x + Mathf.Cos(startAngle + i * sweepAngle / points) * radius);
                    float pointY = (float)(pc.z + Mathf.Sin(startAngle + i * sweepAngle / points) * radius);

                    pointList[i] = new Vector3(pointX, 0, pointY);
                }

                pointList[pointList.Length - 1] = new Vector3(lastPoint.x, 0, lastPoint.z);

                //Check for overlap with other turns
                if (c > 0)
                {
                    if (Vector3.Distance(c1, anglePointPos) > Vector3.Distance(segments[c - 1].c2, anglePointPos))
                    {
                        Debug.LogError("Segments(" + (c - 1) + "&" + c + ") have an interfering turn at " + segments[c - 1].anglePoint.designation + "!");
                    }
                }

                //Check for self overlap with beginning and end points
                if (Vector3.Distance(anglePointPos, c1) > Vector3.Distance(anglePointPos, fromPos))
                {
                    Debug.LogError("Segment " + c + ", has an overlapping turn with the start point!");
                }
                if (Vector3.Distance(anglePointPos, c2) > Vector3.Distance(anglePointPos, toPos))
                {
                    Debug.LogError("Segment " + c + ", has an overlapping turn with the end point!");
                }

                if (Mathf.Abs(sweepAngle) < Mathf.PI - float.Epsilon && Mathf.Abs(sweepAngle) > 0.01f && Mathf.Abs(sweepAngle) > 0)
                {
                    segments[c].AddTurnData(pointList, sweepAngle, radius, pc, c1, c2, fromPos, anglePointPos, toPos, st, end);
                }
            }

            static float TriangleAngle(Vector3 anglePoint, Vector3 p1, Vector3 p2)
            {

                float num = (p1.x - anglePoint.x) * (p2.x - anglePoint.x) + (p1.y - anglePoint.y) * (p2.y - anglePoint.y) + (p1.z - anglePoint.z) * (p2.z - anglePoint.z);

                float den = Mathf.Sqrt(Mathf.Pow((p1.x - anglePoint.x), 2) + Mathf.Pow((p1.y - anglePoint.y), 2) + Mathf.Pow((p1.z - anglePoint.z), 2)) * Mathf.Sqrt(Mathf.Pow((p2.x - anglePoint.x), 2) + Mathf.Pow((p2.y - anglePoint.y), 2) + Mathf.Pow((p2.z - anglePoint.z), 2));

                float angle = Mathf.Acos(num / den) * (180.0f / 3.141592653589793238463f);

                return angle;
            }

            static Vector3 NearestPointOnLine(Vector3 linePnt, Vector3 lineDir, Vector3 pnt)
            {
                //lineDir.Normalize();//this needs to be a unit vector
                var v = pnt - linePnt;
                var d = Vector3.Dot(v, lineDir);
                return linePnt + lineDir * d;
            }

            static float PointAngleDiff(Vector3 anglePoint, Vector3 point1, Vector3 point2)
            {
                return Mathf.Abs((Mathf.PI + Mathf.Atan2(point1.z - anglePoint.z, point1.x - anglePoint.x)) - (Mathf.PI + Mathf.Atan2(point2.z - anglePoint.z, point2.x - anglePoint.x)));
            }
        }

        [Serializable]
        public class RadNavPage
        {
            public RadNavPage()
            {

            }

            public void Clear()
            {

            }
        }

        [Serializable]
        public class FuelPredPage
        {
            public FuelPredPage()
            {

            }

            public void Clear()
            {

            }
        }


        public DirPage dirPage;
        public ProgPage progPage;
        public PerfPage perfPage;
        public InitPage initPage;
        public DataPage dataPage;
        public FPlanPage planPage;
        public RadNavPage radNavPage;
        public FuelPredPage fuelPredPage;



        public void ClearMCDU()
        {
            dirPage.Clear();
            progPage.Clear();
            perfPage.Clear();
            initPage.Clear();
            dataPage.Clear();
            planPage.Clear();
            radNavPage.Clear();
            fuelPredPage.Clear();
        }
    }

    [Serializable]
    public class Engine
    {
        [Serializable]
        public class EngineSound
        {
            [Serializable]
            public class NestedSound
            {
                public string name;

                public AdvancedAudio soundLoop;
                public Vector2 soundRange;
                public AnimationCurve soundFade;
                public AnimationCurve pitchCurve;

                [HideInInspector]
                public float fadeIn = 0;


                public void Init(Transform parent)
                {
                    soundLoop.Init(gb, parent, true);
                }

                public void Update(float rpmPercent, int soundRef)
                {
                    float power = Mathf.Clamp01((rpmPercent - soundRange.x) / (soundRange.y - soundRange.x));
                    soundLoop.StrengthChange(soundRef * fadeIn * soundFade.Evaluate(power));

                    soundLoop.PitchChange(pitchCurve.Evaluate(power));
                }

                public void UpdatePosition(Vector3 position)
                {
                    soundLoop.UpdateVector(position);
                }
            }

            public NestedSound[] engineAudio;
            public float startFadeInTime;
            public AnimationCurve startFadeInCurve;
            public float shutdownFadeOutTime;
            public AnimationCurve shutdownFadeOutCurve;
            public float pitchOffset;
            [HideInInspector]
            public bool fadeIn;
            [HideInInspector]
            public bool fadeOut;
            float fadeTimer = 0;

            [Header("Stats")]
            [Range(0, 1)]
            public float strength;


            public void Init(Transform parent)
            {
                foreach(NestedSound nst in engineAudio)
                {
                    nst.Init(parent);
                }
            }

            public void Update(float value, int soundRef, Vector3 position)
            {
                foreach (NestedSound nst in engineAudio)
                {
                    nst.Update(pitchOffset + value, soundRef);
                    nst.UpdatePosition(position);
                }

                if (fadeIn)
                {
                    fadeTimer += Time.deltaTime / startFadeInTime;

                    foreach (NestedSound nst in engineAudio)
                    {
                        nst.fadeIn = startFadeInCurve.Evaluate(fadeTimer);
                    }


                    if (fadeTimer >= 1)
                    {
                        fadeIn = false;
                        fadeTimer = 0;

                        foreach (NestedSound nst in engineAudio)
                        {
                            nst.fadeIn = startFadeInCurve.Evaluate(1);
                        }
                    }
                }

                if (fadeOut)
                {
                    fadeTimer += Time.deltaTime / shutdownFadeOutTime;

                    foreach (NestedSound nst in engineAudio)
                    {
                        nst.fadeIn = shutdownFadeOutCurve.Evaluate(fadeTimer);
                    }

                    if (fadeTimer >= 1)
                    {
                        fadeOut = false;
                        fadeTimer = 0;

                        foreach (NestedSound nst in engineAudio)
                        {
                            nst.fadeIn = shutdownFadeOutCurve.Evaluate(1);
                        }
                    }
                }

                strength = 0;
                foreach(NestedSound nst in engineAudio)
                {
                    strength += nst.fadeIn;
                }

                strength /= engineAudio.Length;
            }
        }

        public string name;


        public bool debug = false;

        public ReverseDoor[] reverseDoors;
        public HeatDistortion heatDistortion;
        public Particles engineSmoke;
        public AnimationCurve startupSmokeGenerationCurve;
        public bool firstStartup = false;

        public AnimationCurve exhaustVelocityCurve;
        public AnimationCurve heatGeneration;

        public Transform fan;
        public Vector3 fanRotationAxis;

        public Transform thrustPoint;
        public Vector3 thrustAxis;

        public float idleN1rpm;
        public float maxN1rpm;
        public AnimationCurve startupN1Curve;
        public AnimationCurve shutdownN1Curve;
        public AnimationCurve N1RelationToN2;

        public float idleN2rpm;
        public float maxN2rpm;
        public AnimationCurve startupN2Curve;
        public AnimationCurve shutdownN2Curve;

        public float maxEngineThrust;
        float thrustFactor;

        public AnimationCurve n1ThrustCurve;
        public AnimationCurve n2ThrustCurve;

        public float reverseThrustDiversionRate;
        public float maxReverseThrottle;

        public float baseInertia;
        public AnimationCurve inertiaThroughRpm;
        public float shutdownInertia;
        public AnimationCurve shutdownInertiaCurve;

        public AdvancedAudio startSound;
        public AdvancedAudio shutdownSound;
        public AdvancedAudio reverseSound;
        public AnimationCurve reverseSoundCurve;
        public AnimationCurve reversePitchCurve;
        public AnimationCurve shutdownFadeInCurve;
        public float shutdownFadeInTime;
        float shutdownFadeInTimer = 0;
        bool fadeInShutdownSound = false;
        public EngineSound engineSound;
        public Transform soundPoint;

        Vector3 soundOrigin;

        public float shutdownTime;
        public float startTime;
        float runTimer;

        [Space(15)]

        public AnimationCurve fanPressureRatioCurve;
        public AnimationCurve burnerPressureRatioCurve;
        public AnimationCurve compressorPressureRatioCurve;

        public AnimationCurve efficiency_diffuser_curve;
        public AnimationCurve efficiency_compressor_curve;
        public AnimationCurve efficiency_turbine_curve;
        public AnimationCurve efficiency_nozzle_curve;
        public AnimationCurve efficiency_fan_curve;
        public AnimationCurve efficiency_fanNozzle_curve;

        [Header("Specifications")]
        [Tooltip("Meters")]
        public float fanDiameter;
        public float fanExhaustDiameter;
        public float coreExhaustDiameter;
        public float fuelHeatingValue;
        public float turbineInletTemp;
        public float bypassRatio;
        public float heatRatio_ambientAir;
        public float heatRatio_diffuser;
        public float heatRatio_fan;
        public float heatRatio_compressor;
        public float heatRatio_burner;
        public float heatRatio_turbine;
        public float heatRatio_nozzle;

        float gasProperty_R;
        float gasProperty_cp;

        [Header("Stats")]
        public SmoothFloat N1rpm;
        [Range(0, 100)]
        public float N1rpmPercent;
        public SmoothFloat N2rpm;
        [Range(0, 100)]
        public float N2rpmPercent;
        public bool soundRefEngine = false;

        [Space(10)]
        public float compressorInletTemp;
        public float compressorInletPress;
        public float compressorOutletTemp;
        public float compressorOutletPress;
        public float burnerFuelToAirRatio;
        public float turbineInletPress;
        public float turbineOutletTemp;
        public float turbineOutletPress;
        public float fanOutletTemp;
        public float fanOutletPress;
        public float flightVelocity;
        public float nozzleExitVelocity;
        public float nozzleExitMassFlow;
        public float fanNozzleExitVelocity;
        public float fanNozzleExitMassFlow;
        public float thrustPerAirMassFlowRate;
        public float fuelFlowRatePerThrust;

        public float compressorPressureRatio;
        public float burnerPressureRatio;
        public float fanPressureRatio;

        public float efficiency_diffuser;
        public float efficiency_compressor;
        public float efficiency_turbine;
        public float efficiency_nozzle;
        public float efficiency_fan;
        public float efficiency_fanNozzle;

        public float propulsionEfficiency;

        public float N1thrust;
        public float N2thrust;
        public float totalThrust;

        [Space(10)]

        public int state;
        public bool starting = false;
        public bool shutting = false;
        public bool ready = false;
        public bool bleedOn = false;

        public bool reverse = false;


        public void Init(float airDensity, float velocity, float machSpeed, float ambientTemp, float ambientPressure)
        {
            foreach(ReverseDoor rvr in reverseDoors)
            {
                rvr.Init();
            }

            heatDistortion.Init();
            engineSmoke.Init();
            
            engineSound.Init(soundPoint);
            reverseSound.Init(gb, soundPoint, true);

            state = 0;

            fanPressureRatio = fanPressureRatioCurve.Evaluate(1);
            burnerPressureRatio = burnerPressureRatioCurve.Evaluate(1);
            compressorPressureRatio = compressorPressureRatioCurve.Evaluate(1);

            efficiency_diffuser = efficiency_diffuser_curve.Evaluate(1);
            efficiency_compressor = efficiency_compressor_curve.Evaluate(1);
            efficiency_turbine = efficiency_turbine_curve.Evaluate(1);
            efficiency_nozzle = efficiency_nozzle_curve.Evaluate(1);
            efficiency_fan = efficiency_fan_curve.Evaluate(1);
            efficiency_fanNozzle = efficiency_fanNozzle_curve.Evaluate(1);

            soundOrigin = soundPoint.transform.localPosition;

            CalculateEngineSpecs(airDensity, velocity, machSpeed, ambientTemp, ambientPressure);

            for (float i = 50f; i > 1; i -= 0.005f)
            {
                float n1 = n1ThrustCurve.Evaluate(1) * ((thrustPerAirMassFlowRate * fanNozzleExitMassFlow) / i);
                float n2 = n1ThrustCurve.Evaluate(1) * ((thrustPerAirMassFlowRate * nozzleExitMassFlow) / i);
                float t = n1 + n2;

                if (t >= maxEngineThrust)
                {
                    thrustFactor = i;
                    break;
                }
            }
        }

        public void FixedUpdate(float airDensity, float velocity, float machSpeed, float ambientTemp, float ambientPressure)
        {
            CalculateEngineSpecs(airDensity, velocity, machSpeed, ambientTemp, ambientPressure);

            N1thrust = n1ThrustCurve.Evaluate(N1rpm.smoothValue / maxN1rpm) * ((thrustPerAirMassFlowRate * fanNozzleExitMassFlow) / thrustFactor);
            N2thrust = n1ThrustCurve.Evaluate(N2rpm.smoothValue / maxN2rpm) * ((thrustPerAirMassFlowRate * nozzleExitMassFlow) / thrustFactor);
            totalThrust = N1thrust + N2thrust;


            if (!reverse)
            {
                rb.AddForceAtPosition(thrustPoint.transform.TransformDirection(thrustAxis.normalized) * totalThrust, thrustPoint.transform.position);
            }
            else
            {
                rb.AddForceAtPosition(thrustPoint.transform.TransformDirection(thrustAxis.normalized) * (((reverseThrustDiversionRate * -N1thrust) + (N1thrust * (1 - reverseThrustDiversionRate))) + N2thrust), thrustPoint.transform.position);
            }
        }

        public void Update(A320Pilot.Throttle throttle, Vector3 soundPosition)
        {
            N1rpm.Update(SmoothFloat.UpdateType.Update);
            N2rpm.Update(SmoothFloat.UpdateType.Update);

            N1rpmPercent = (N1rpm.smoothValue / maxN1rpm) * 100;
            N2rpmPercent = (N2rpm.smoothValue / maxN2rpm) * 100;

            heatDistortion.Update(exhaustVelocityCurve.Evaluate(N2rpmPercent / 100), heatGeneration.Evaluate(N2rpmPercent / 100));

            Vector3 soundPos = ((1 - Convert.ToInt32(soundRefEngine)) * soundPoint.transform.TransformPoint(soundOrigin)) + (Convert.ToInt32(soundRefEngine) * soundPosition);

            foreach (ReverseDoor rvr in reverseDoors)
            {
                rvr.Update();
            }

            if(starting || shutting || ready)
            {
                engineSound.Update(N1rpmPercent, Convert.ToInt32(soundRefEngine), soundPos);
            }

            if (!starting && ready)
            {
                if (!reverse)
                {
                    N2rpm.ValueChange(idleN2rpm + (Mathf.Clamp01((throttle.realThrottle - (idleN1rpm / maxN1rpm)) * (1 + (idleN1rpm / maxN1rpm))) * (maxN2rpm - idleN2rpm)));
                    N2rpm.smoothing = inertiaThroughRpm.Evaluate(N2rpm.smoothValue / maxN2rpm) * baseInertia;

                    N1rpm.ValueChange(idleN1rpm + (((N2rpm.smoothValue - idleN2rpm) / (maxN2rpm - idleN2rpm)) * (maxN1rpm - idleN1rpm)));
                    N1rpm.smoothing = N1RelationToN2.Evaluate((N2rpm.smoothValue - idleN2rpm) / (maxN2rpm - idleN2rpm)) * baseInertia;
                }
                else
                {
                    N2rpm.ValueChange(idleN2rpm + (Mathf.Clamp01(((maxReverseThrottle - (idleN1rpm / maxN1rpm)) * throttle.reverse) * (1 + (idleN1rpm / maxN1rpm))) * (maxN2rpm - idleN2rpm)));
                    N2rpm.smoothing = inertiaThroughRpm.Evaluate(N2rpm.smoothValue / maxN2rpm) * baseInertia;

                    N1rpm.ValueChange(idleN1rpm + (((N2rpm.smoothValue - idleN2rpm) / (maxN2rpm - idleN2rpm)) * (maxN1rpm - idleN1rpm)));
                    N1rpm.smoothing = N1RelationToN2.Evaluate((N2rpm.smoothValue - idleN2rpm) / (maxN2rpm - idleN2rpm)) * baseInertia;

                    reverseSound.StrengthChange(reverseSoundCurve.Evaluate(N1rpmPercent / (100 * maxReverseThrottle)));
                    reverseSound.PitchChange(reversePitchCurve.Evaluate(N1rpmPercent / (100 * maxReverseThrottle)));
                    reverseSound.UpdateVector(soundPos);
                }
            }

            if (starting)
            {
                if (N2rpm.GetValue() < idleN2rpm)
                {
                    runTimer += Time.deltaTime / startTime;
                    N2rpm.ValueChange(startupN2Curve.Evaluate(runTimer) * idleN2rpm);
                    N1rpm.ValueChange(startupN1Curve.Evaluate(runTimer) * idleN1rpm);

                    if (firstStartup)
                    {
                        engineSmoke.Update(startupSmokeGenerationCurve.Evaluate(runTimer), N2rpm.smoothValue / idleN2rpm);
                    }
                }
                else
                {
                    N2rpm.ValueChange(startupN2Curve.Evaluate(1) * idleN2rpm);
                    N1rpm.ValueChange(startupN1Curve.Evaluate(1) * idleN1rpm);

                    if (firstStartup)
                    {
                        engineSmoke.Update(0, 0);
                        firstStartup = false;
                    }
                }
            }
            else if (shutting)
            {
                if(N2rpm.GetValue() > 0)
                {
                    N2rpm.ValueChange(N2rpm.GetValue() - (Time.deltaTime / (shutdownInertiaCurve.Evaluate(N2rpm.smoothValue / idleN2rpm) * (shutdownInertia / 5f))));
                }
                else
                {
                    N2rpm.ValueChange(0);
                }

                if (N1rpm.GetValue() > 0)
                {
                    N1rpm.ValueChange(N1rpm.GetValue() - (Time.deltaTime / (shutdownInertiaCurve.Evaluate(N1rpm.smoothValue / idleN1rpm) * shutdownInertia))); 
                }
                else
                {
                    N1rpm.ValueChange(0);
                }

                if (fadeInShutdownSound)
                {
                    shutdownFadeInTimer += Time.deltaTime / shutdownFadeInTime;

                    shutdownSound.StrengthChange(shutdownFadeInCurve.Evaluate(shutdownFadeInTimer));
                    if (shutdownFadeInTimer >= 1)
                    {
                        fadeInShutdownSound = false;
                        shutdownFadeInTimer = 0;

                        shutdownSound.StrengthChange(shutdownFadeInCurve.Evaluate(1));
                    }
                }

                if (N2rpm.GetValue() < 5f)
                {
                    shutting = false;
                }
            }

            fan.transform.Rotate(fanRotationAxis.normalized * (Time.deltaTime * (N1rpm.smoothValue * 6)));

            if(throttle.inReverse)
            {
                if (!reverse)
                {
                    ToggleReverse(1);
                    reverse = true;
                }
            }
            else
            {
                if (reverse)
                {
                    ToggleReverse(0);
                    reverseSound.StrengthChange(0);
                    reverse = false;
                }
            }
        }

        void CalculateEngineSpecs(float airDensity, float velocity, float machSpeed, float ambientTemp, float ambientPressure)
        {
            /*this is the computational core, performs turbofan analysis
            *based on the equations derived in Chap.5 of Hill and Peterson*/

            /*gas properties*/
            gasProperty_R = (8.3143f / 28.96f) * 1000;
            gasProperty_cp = heatRatio_ambientAir / (heatRatio_ambientAir - 1) * gasProperty_R;

            /*inlet velocity*/
            flightVelocity = machSpeed * Mathf.Sqrt(heatRatio_ambientAir * gasProperty_R * ambientTemp);
            float flightMassFlowRate = airDensity * velocity * (Mathf.PI * Mathf.Pow(fanDiameter / 2, 2));

            /*compressor inlet*/
            compressorInletTemp = ambientTemp * (1 + (heatRatio_ambientAir - 1) / 2 * machSpeed * machSpeed);       /*5.37*/
            compressorInletPress = ambientPressure * Mathf.Pow(1 + efficiency_diffuser * (compressorInletTemp / ambientTemp - 1), heatRatio_diffuser / (heatRatio_diffuser - 1));   /*5.38*/

            /*compressor outlet*/
            compressorOutletPress = compressorInletPress * compressorPressureRatio;    /*5.39*/
            compressorOutletTemp = compressorInletTemp * (1 + (1 / efficiency_compressor) * (Mathf.Pow(compressorPressureRatio, (heatRatio_compressor - 1) / heatRatio_compressor) - 1));  /*5.40*/

            /*burner fuel-air ratio*/
            burnerFuelToAirRatio = (turbineInletTemp - compressorOutletTemp) / (fuelHeatingValue / gasProperty_cp - turbineInletTemp);    /*5.41*/

            /*turbine inlet*/
            turbineInletPress = compressorOutletPress * burnerPressureRatio;     /*5.42*/

            /*fan outlet*/
            fanOutletPress = compressorInletPress * fanPressureRatio;   /*5.48*/
            fanOutletTemp = compressorInletTemp * (1 + (1 / efficiency_fan) * (Mathf.Pow(fanPressureRatio, (heatRatio_fan - 1) / heatRatio_fan) - 1));   /*5.49*/

            /*turbine outlet*/
            turbineOutletTemp = turbineInletTemp - (compressorOutletTemp - compressorInletTemp) - bypassRatio * (fanOutletTemp - compressorInletTemp);     /*5.51*/
            turbineOutletPress = turbineInletPress * Mathf.Pow(1 - (1 / efficiency_compressor) * (1 - turbineOutletTemp / turbineInletTemp), heatRatio_turbine / (heatRatio_turbine - 1));

            /*nozzle exit*/
            nozzleExitVelocity = Mathf.Sqrt(2 * efficiency_nozzle * (heatRatio_nozzle / (heatRatio_nozzle - 1)) * gasProperty_R * turbineOutletTemp * (1 - Mathf.Pow(ambientPressure / turbineOutletPress, (heatRatio_nozzle - 1) / heatRatio_nozzle)));   /*5.45*/
            nozzleExitMassFlow = airDensity * nozzleExitVelocity * (Mathf.PI * Mathf.Pow(coreExhaustDiameter / 2, 2));

            /*fan nozzle exit*/
            fanNozzleExitVelocity = Mathf.Sqrt(2 * efficiency_fanNozzle * (heatRatio_fan / (heatRatio_fan - 1)) * gasProperty_R * fanOutletTemp * (1 - Mathf.Pow(ambientPressure / fanOutletPress, (heatRatio_fan - 1) / heatRatio_fan)));   /*5.50*/
            fanNozzleExitMassFlow = airDensity * fanNozzleExitVelocity * ((Mathf.Pow(fanExhaustDiameter / 2, 2) - Mathf.Pow(coreExhaustDiameter / 2, 2)) * Mathf.Pow(Mathf.PI, 2));

            /*specific thrust*/
            thrustPerAirMassFlowRate = (1 + burnerFuelToAirRatio) * nozzleExitVelocity + bypassRatio * fanNozzleExitVelocity - (1 + bypassRatio) * velocity;

            /*TSFC*/
            fuelFlowRatePerThrust = burnerFuelToAirRatio / thrustPerAirMassFlowRate;  /*5.47*/

            /*propulsion efficiency*/
            propulsionEfficiency = thrustPerAirMassFlowRate * velocity / (0.5f * ((1 + burnerFuelToAirRatio) * nozzleExitVelocity * nozzleExitVelocity + bypassRatio * fanNozzleExitVelocity * fanNozzleExitVelocity - (1 + bypassRatio) * velocity * velocity));
        }

        public void ToggleReverse(int state)
        {
            foreach (ReverseDoor rvr in reverseDoors)
            {
                rvr.SwitchState(state);
            }
        }

        public IEnumerator Startup(bool apuBleed)
        {
            if (!starting && !ready && !shutting && pilot.throttle.ThrottleDetent() == 0 && apuBleed)
            {
                state = 1;
                starting = true;

                startSound.PlayOneShot(gb, soundPoint, 0, 1, 1);

                yield return new WaitForSeconds(startTime - engineSound.startFadeInTime);

                engineSound.fadeIn = true;

                yield return new WaitWhile(() => engineSound.fadeIn);

                starting = false;
                ready = true;
                state = 2;
            }
        }

        public IEnumerator Shutdown()
        {
            if (!starting && ready && !shutting && pilot.throttle.ThrottleDetent() == 0)
            {
                state = 1;
                shutting = true;
                ready = false;
                bleedOn = false;

                shutdownSound.PlayOneShot(gb, soundPoint, 0, 0, 1);
                fadeInShutdownSound = true;
                engineSound.fadeOut = true;

                yield return new WaitForSeconds(shutdownTime);
                yield return new WaitWhile(() => engineSound.fadeOut);

                shutting = false;
                state = 0;
            }
        }

        public void SetBleed(bool state)
        {
            if (ready)
            {
                bleedOn = state;
            }
        }
    }

    [Serializable]
    public class HeatDistortion
    {
        public ParticleSystem particleSystem;
        ParticleSystemRenderer renderer;

        public Vector2 speedLimits;
        public AnimationCurve speedCurve;
        public Vector2 rateLimits;
        public AnimationCurve rateCurve;

        public Vector2 distortionLimits;

        [Header("Stats")]
        public bool emitting = false;


        public void Init()
        {
            renderer = particleSystem.GetComponent<ParticleSystemRenderer>();

            Emit(false);
        }

        public void Update(float speed, float heat)
        {
            var main = particleSystem.main;
            main.startSpeed = speedLimits.x + (speedCurve.Evaluate(speed) * (speedLimits.y - speedLimits.x));
            var emission = particleSystem.emission;
            emission.rateOverTime = rateLimits.x + (rateCurve.Evaluate(speed) * (rateLimits.y - rateLimits.x));

            renderer.material.SetFloat("HeatDistortion", distortionLimits.x + (heat * (distortionLimits.y - distortionLimits.x)));
            
            if(heat > 0)
            {
                if (!emitting)
                {
                    Emit(true);
                }
            }
            else
            {
                if (emitting)
                {
                    Emit(false);
                }
            }
        }

        public void Emit(bool state)
        {
            var emission = particleSystem.emission;
            emission.enabled = state;

            emitting = state;
        }
    }

    [Serializable]
    public class Particles
    {
        public ParticleSystem particleSystem;
        ParticleSystemRenderer renderer;

        public Vector2 speedLimits;
        public AnimationCurve speedCurve;
        public Vector2 rateLimits;
        public AnimationCurve rateCurve;

        [Header("Stats")]
        public bool emitting = false;


        public void Init()
        {
            renderer = particleSystem.GetComponent<ParticleSystemRenderer>();

            Emit(false);
        }

        public void Update(float rate, float speed)
        {
            var main = particleSystem.main;
            main.startSpeed = speedLimits.x + (speedCurve.Evaluate(speed) * (speedLimits.y - speedLimits.x));
            var emission = particleSystem.emission;
            emission.rateOverTime = rateLimits.x + (rateCurve.Evaluate(rate) * (rateLimits.y - rateLimits.x));

            if (rate > 0)
            {
                if (!emitting)
                {
                    Emit(true);
                }
            }
            else
            {
                if (emitting)
                {
                    Emit(false);
                }
            }
        }

        public void Emit(bool state)
        {
            var emission = particleSystem.emission;
            emission.enabled = state;

            emitting = state;
        }
    }

    [Serializable]
    public class APU
    {
        public HeatDistortion apuHeatDistortion;
        [Range(0, 100)]
        public float apuRpmPercent;
        public AnimationCurve apuExhaustVelocityCurve;
        public AnimationCurve apuHeatGeneration;
        public AdvancedAudio apuStartSound;
        public AdvancedAudio apuShutdownSound;
        public AdvancedAudio apuSoundLoop;
        public AnimationCurve startupRpmCurve;
        public AnimationCurve shutdownRpmCurve;
        public Transform apuSoundPoint;

        public float apuShutdownTime;
        public float apuStartTime;
        float runTimer;

        [Header("Stats")]
        public int state;
        public bool apuStarting = false;
        public bool apuShutting = false;
        public bool apuReady = false;
        public bool apuBleed = false;


        public void Init()
        {
            apuHeatDistortion.Init();
            apuSoundLoop.Init(gb, apuSoundPoint.transform, false);

            apuStarting = false;
            apuShutting = false;
            apuReady = false;

            state = 0;
        }

        public void Update()
        {
            apuHeatDistortion.Update(apuExhaustVelocityCurve.Evaluate(apuRpmPercent / 100), apuHeatGeneration.Evaluate(apuRpmPercent / 100));

            if (apuStarting)
            {
                if(apuRpmPercent < 100f)
                {
                    runTimer += Time.deltaTime / apuStartTime;
                    apuRpmPercent = startupRpmCurve.Evaluate(runTimer) * 100;

                }
                else
                {
                    apuRpmPercent = 100f;
                }
            }
            else if (apuShutting)
            {
                if (apuRpmPercent > 0)
                {
                    runTimer -= Time.deltaTime / apuShutdownTime;
                    apuRpmPercent = shutdownRpmCurve.Evaluate(runTimer) * 100;
                }
                else
                {
                    apuRpmPercent = 0;
                }
            }
        }

        public IEnumerator Startup(bool batteriesOn)
        {
            if (!apuStarting && !apuShutting && !apuReady && batteriesOn)
            {
                state = 1;
                apuStarting = true;
                runTimer = 0;

                apuStartSound.PlayOneShot(gb, apuSoundPoint, 0, 1, 1);

                yield return new WaitForSeconds(apuStartTime);

                apuSoundLoop.StrengthChange(1);

                yield return new WaitForSeconds(0.5f);

                apuStarting = false;
                apuReady = true;
                state = 2;
            }
        }

        public IEnumerator Shutdown()
        {
            if (!apuStarting && !apuShutting && apuReady)
            {
                state = 1;
                apuBleed = false;
                apuReady = false;
                apuShutting = true;
                runTimer = 1;

                apuSoundLoop.StrengthChange(0);
                apuShutdownSound.PlayOneShot(gb, apuSoundPoint, 0, 1, 1);

                yield return new WaitForSeconds(apuShutdownTime);

                apuShutting = false;
                state = 0;
            }
        }

        public void SetBleed(bool state)
        {
            if (apuReady)
            {
                apuBleed = state;
            }
        }
    }

    [Serializable]
    public class LandLightComponent
    {
        public Transform lightPivot;
        public Transform upperArm;
        public Vector3 defaultUpperArmRotation;
        public Vector3 upperArmRotationAxis;
        public Vector3 upperArmRotationAmount;
        public Transform lowerArm;
        public Vector3 defaultLowerArmRotation;
        public Vector3 lowerArmRotationAxis;
        public Vector3 lowerArmRotationAmount;
        public Vector3 defaultRotation;
        public Vector3 openingAmount;

        public float openingTime;
        private float openTimer;

        [Header("Stats")]
        public int state = 0;


        public void Init()
        {
            if (state == 3)
            {
                lightPivot.transform.localEulerAngles = defaultRotation + openingAmount;
                lowerArm.transform.localEulerAngles = defaultLowerArmRotation + lowerArmRotationAmount;
                upperArm.transform.localEulerAngles = defaultUpperArmRotation + upperArmRotationAmount;
            }
            else if (state == 0)
            {
                lightPivot.transform.localEulerAngles = defaultRotation;
                lowerArm.transform.localEulerAngles = defaultLowerArmRotation;
                upperArm.transform.localEulerAngles = defaultUpperArmRotation;
            }
        }

        public void Update()
        {
            if (state == 2)
            {
                openTimer += Time.deltaTime / openingTime;
                lightPivot.transform.localEulerAngles = defaultRotation + (openTimer * openingAmount);
                lowerArm.transform.localEulerAngles = defaultLowerArmRotation + (openTimer * lowerArmRotationAmount);
                upperArm.transform.localEulerAngles = defaultUpperArmRotation + (openTimer * upperArmRotationAmount);

                if (openTimer >= 1)
                {
                    state = 3;
                    openTimer = 0;
                }
            }
            else if (state == 1)
            {
                openTimer += Time.deltaTime / openingTime;
                lightPivot.transform.localEulerAngles = defaultRotation + ((1 - openTimer) * openingAmount);
                lowerArm.transform.localEulerAngles = defaultLowerArmRotation + ((1 - openTimer) * lowerArmRotationAmount);
                upperArm.transform.localEulerAngles = defaultUpperArmRotation + ((1 - openTimer) * upperArmRotationAmount);

                if (openTimer >= 1)
                {
                    state = 0;
                    openTimer = 0;
                }
            }
        }

        public void SwitchState(int _state)
        {
            if (_state == 1)
            {
                if(state != 3 && state != 2)
                {
                    state = 2;
                    openTimer = 0;
                }
            }
            else if (_state == 0)
            {
                if(state != 0 && state != 1)
                {
                    state = 1;
                    openTimer = 0;
                }
            }
        }
    }

    [Serializable]
    public class AircraftLight
    {
        [Serializable]
        public class AdvancedLight
        {
            public Light light;
            public Transform emissionObject;
            [HideInInspector]
            public Renderer emissionMaterial;
            public Color color;
        }

        public string name;

        public AdvancedLight[] lightObject;
        public Vector2 emissionLimits;
        public SmoothFloat currentBrightness = new SmoothFloat(0, new Vector2(0, 100), 0.3f);

        public float[] lightSequence;
        float sequenceTimer;
        int sequenceIndex;

        public int state;


        public void Init()
        {
            foreach(AdvancedLight l in lightObject)
            {
                l.emissionMaterial = l.emissionObject.GetComponent<Renderer>();
                l.light.color = l.color;
            }

            if (state > 1)
            {
                state = 0;
            }
            else if (state < 0)
            {
                state = 0;
            }

            currentBrightness.SetRawValue(state * currentBrightness.limits.y);
        }

        public void Update(float powerSupply)
        {
            currentBrightness.Update(SmoothFloat.UpdateType.Update);

            foreach(AdvancedLight l in lightObject)
            {
                l.light.intensity = powerSupply * currentBrightness.smoothValue;
                l.emissionMaterial.material.SetColor("_EmissionColor", l.color * Mathf.Pow(2.0f, emissionLimits.x + ((currentBrightness.smoothValue / currentBrightness.limits.y) * (emissionLimits.y - emissionLimits.x)) - 0.4169f));
            }
            
            if(state == 1 && lightSequence.Length > 0)
            {
                sequenceTimer -= Time.deltaTime;

                if(sequenceTimer <= 0)
                {
                    if(sequenceIndex < lightSequence.Length - 1)
                    {
                        sequenceIndex++;
                    }
                    else
                    {
                        sequenceIndex = 0;
                    }

                    currentBrightness.ValueChange((sequenceIndex + 2) % 2 * currentBrightness.limits.y);

                    sequenceTimer = lightSequence[sequenceIndex];
                }
            }
        }

        public void SwitchState()
        {
            if (state == 1)
            {
                state = 0;
            }
            else if (state == 0)
            {
                state = 1;
            }

            if (lightSequence.Length > 0)
            {
                sequenceTimer = lightSequence[0];
                sequenceIndex = 0;
                currentBrightness.ValueChange((sequenceIndex + 2) % 2 * currentBrightness.limits.y);
            }
            else
            {
                currentBrightness.ValueChange(state * currentBrightness.limits.y);
            }
        }

        public void SwitchState(int _state)
        {
            state = _state;

            if (lightSequence.Length > 0)
            {
                sequenceTimer = lightSequence[0];
                sequenceIndex = 0;
                currentBrightness.ValueChange((sequenceIndex + 2) % 2 * currentBrightness.limits.y);
            }
            else
            {
                currentBrightness.ValueChange(state * currentBrightness.limits.y);
            }
        }
    }

    [Serializable]
    public class ReverseDoor
    {
        public string name;

        public Transform door;
        public Transform hydraulicArm;
        public Transform hydraulicArmBody;
        public float maxAngle;
        
        public Vector3 axis;

        Vector3 originPoint;

        [Header("Stats")]
        public SmoothFloat currentAngle = new SmoothFloat(0, new Vector2(0, 80), 0.2f);
        public int state = 0;


        public void Init()
        {
            originPoint = door.transform.localEulerAngles;
        }

        public void Update()
        {
            currentAngle.Update(SmoothFloat.UpdateType.Update);

            door.transform.localEulerAngles = originPoint + (axis.normalized * currentAngle.smoothValue);
            hydraulicArm.transform.LookAt(hydraulicArmBody.transform.position);
            hydraulicArmBody.transform.LookAt(hydraulicArm.transform.position);
        }

        public void SwitchState(int _state)
        {
            state = _state;
            currentAngle.ValueChange(_state * maxAngle);
        }
    }

    [Serializable]
    public class Wheel
    {
        [Serializable]
        public class ModifiedVertex
        {
            public int index;
            public int segmentIndex;
            public Vector3 localPosition;

            float sideDeformation_cached;
            float inwardDeformation_cached;


            public ModifiedVertex(int _index, int _segmentIndex, Vector3 _localPosition)
            {
                index = _index;
                segmentIndex = _segmentIndex;
                localPosition = _localPosition;
            }

            public void Init(AnimationCurve inwardDeformation, AnimationCurve sideDeformation, int segmentSize)
            {
                sideDeformation_cached = sideDeformation.Evaluate((float)segmentIndex / (segmentSize - 1));
                inwardDeformation_cached = inwardDeformation.Evaluate((float)segmentIndex / (segmentSize - 1));
            }

            public Vector3 Update(Vector3 modified, float compression, Vector3 direction, float tireRotation, float maxMovement, int segmentSize, float wheelRadius, int segmentAmount, Vector3 sideDirection, Transform rayPoint, Vector3 adjustedRotation, int segment)
            {
                float segmentHeight = wheelRadius * (1 - Mathf.Cos((Mathf.Abs((TranslateTo180(tireRotation + (segment * (360f / segmentAmount)))) * 2) * Mathf.Deg2Rad) / 2));
                float distanceModifier = (1 / maxMovement) * Mathf.Clamp((compression * maxMovement) - segmentHeight, 0, maxMovement);
                float widthModifier = (1 / maxMovement) * Mathf.Clamp((compression * maxMovement) - (segmentHeight / 4), 0, maxMovement);
                modified = localPosition - (distanceModifier * (inwardDeformation_cached * (adjustedRotation * maxMovement))) - (widthModifier * (sideDeformation_cached * (sideDirection.normalized * maxMovement)));
                return modified;
            }

            public float TranslateTo180(float rotation)
            {
                rotation %= 360f;

                if (rotation > 180)
                {
                    return rotation - 180;
                }
                else if (rotation <= 180)
                {
                    return rotation - 180;
                }

                return 0;
            }
        }

        [Serializable]
        public class ModifiedSegment
        {
            public int segmentIndex;
            public List<ModifiedVertex> vertices;

            bool initDone = false;


            public ModifiedSegment(int _segmentIndex, List<ModifiedVertex> _vertices)
            {
                segmentIndex = _segmentIndex;
                vertices = _vertices;
            }

            public Vector3[] Update(Vector3[] modifiedVertices, float compression, Vector3 direction, float tireRotation, float maxMovement, AnimationCurve inwardDeformation, AnimationCurve sideDeformation, int segmentSize, float wheelRadius, int segmentAmount, Vector3 sideDirection, Transform rayPoint)
            {
                if (!initDone)
                {
                    foreach (ModifiedVertex mdv in vertices)
                    {
                        mdv.Init(inwardDeformation, sideDeformation, segmentSize);
                    }

                    initDone = true;
                }

                float tireRot = 360f - (tireRotation + Vector3.Angle(direction.normalized, rayPoint.transform.up));
                Vector3 adjustedRot = Quaternion.Euler(Vector3.right * (360f - tireRot)) * -Vector3.forward;

                foreach (ModifiedVertex mdv in vertices)
                {
                    modifiedVertices[mdv.index] = mdv.Update(modifiedVertices[mdv.index], compression, direction, tireRot, maxMovement, segmentSize, wheelRadius, segmentAmount, sideDirection, rayPoint, adjustedRot, segmentIndex);
                }

                return modifiedVertices;
            }
        }

        [Serializable]
        public class LateralParameters
        {
            [Header("Pure side slip")]
            [Tooltip("Shape factor Cfy for lateral forces")]
            public float pcy1 = 1.2664f;
            [Tooltip("Lateral friction Muy")]
            public float pdy1 = 0.949f;
            [Tooltip("Variation of friction Muy with load")]
            public float pdy2 = -0.13463f;
            [Tooltip("Variation of friction Muy with squared camber")]
            public float pdy3 = 0.8261f;
            [Tooltip("Lateral curvature Efy at Fznom")]
            public float pey1 = -1.3159f;
            [Tooltip("Variation of curvature Efy with load")]
            public float pey2 = -0.4004f;
            [Tooltip("Zero order camber dependency of curvature Efy")]
            public float pey3 = 0.1824f;
            [Tooltip("Variation of curvature Efy with camber")]
            public float pey4 = -8.101f;
            [Tooltip("Unknown")]
            public float pey5 = 0;
            [Tooltip("Maximum value of stiffness Kfy/Fznom")]
            public float pky1 = -16.832f;
            [Tooltip("Load at which Kfy reaches maximum value")]
            public float pky2 = 2.101f;
            [Tooltip("Variation of Kfy/Fznom with camber")]
            public float pky3 = -0.10954f;
            [Tooltip("Unknown")]
            public float pky4 = 2;
            [Tooltip("Unknown")]
            public float pky5 = 0;
            [Tooltip("Horizontal shift Shy at Fznom")]
            public float phy1 = 0.0015064f;
            [Tooltip("Variation of shift Shy with load")]
            public float phy2 = 0.0043944f;
            [Tooltip("Variation of shift Shy with camber")]
            public float phy3 = 0.03976f;
            [Tooltip("Vertical shift in Svy/Fz at Fznom")]
            public float pvy1 = 0.005431f;
            [Tooltip("Variation of shift Svy/Fz with load")]
            public float pvy2 = 0.022704f;
            [Tooltip("Variation of shift Svy/Fz with camber")]
            public float pvy3 = -0.0771f;
            [Tooltip("Variation of shift Svy/Fz with camber and load")]
            public float pvy4 = -0.09083f;
            [Tooltip("Peak value of relaxation length SigAlp0/R0")]
            public float pty1 = 2.1439f;
            [Tooltip("Value of Fz/Fznom where SigAlp0 is extreme")]
            public float pty2 = 1.9829f;
            [Tooltip("Unknown")]
            public float pty3 = -0.90729f;

            [Header("Combined slip")]
            [Tooltip("Slope factor for combined Fy reduction")]
            public float rby1 = 9.58f;
            [Tooltip("Variation of slope Fy reduction with alpha")]
            public float rby2 = 8.813f;
            [Tooltip("Shift term for alpha in slope Fy reduction")]
            public float rby3 = -0.014943f;
            [Tooltip("Shape factor for combined Fy reduction")]
            public float rcy1 = 1.0203f;
            [Tooltip("Shift factor for combined Fy reduction")]
            public float rhy1 = 0.007964f;
            [Tooltip("Shift factor for combined Fy reduction with load")]
            public float rhy2 = 0;
            [Tooltip("Kappa induced side force Svyk/Muy*Fz at Fznom")]
            public float rvy1 = 0.01058f;
            [Tooltip("Variation of Svyk/Muy*Fz with load")]
            public float rvy2 = 0.0333f;
            [Tooltip("Variation of Svyk/Muy*Fz with camber")]
            public float rvy3 = 0.825f;
            [Tooltip("Variation of Svyk/Muy*Fz with alpha")]
            public float rvy4 = 116.72f;
            [Tooltip("Variation of Svyk/Muy*Fz with kappa")]
            public float rvy5 = 1.9f;
            [Tooltip("Variation of Svyk/Muy*Fz with atan(kappa)")]
            public float rvy6 = -27.59f;
        }

        [Serializable]
        public class LongitudinalParameters
        {
            [Header("Pure longitudinal slip")]
            [Tooltip("Shape factor Cfx for longitudinal force")]
            public float pcx1 = 1.4146f;
            [Tooltip("Longitudinal friction Mux at Fznom")]
            public float pdx1 = 1.1264f;
            [Tooltip("Variation of friction Mux with load")]
            public float pdx2 = 0.18176f;
            [Tooltip("Longitudinal curvature Efx at Fznom")]
            public float pex1 = 0.001242f;
            [Tooltip("Variation of curvature Efx with load")]
            public float pex2 = 0.004268f;
            [Tooltip("Variation of curvature Efx with load squared")]
            public float pex3 = 0.005999f;
            [Tooltip("Factor in curvature Efx while driving")]
            public float pex4 = 314.36f;
            [Tooltip("Longitudinal slip stiffness Kfx/Fz at Fznom")]
            public float pkx1 = 36.12f;
            [Tooltip("Variation of slip stiffness Kfx/Fz with load")]
            public float pkx2 = 11.489f;
            [Tooltip("Exponent in slip stiffness Kfx/Fz with load")]
            public float pkx3 = 0.1678f;
            [Tooltip("Horizontal shift Shx at Fznom")]
            public float phx1 = -0.0017105f;
            [Tooltip("Variation of shift Shx with load")]
            public float phx2 = 0.0030235f;
            [Tooltip("Vertical shift Svx/Fz at Fznom")]
            public float pvx1 = 0.06054f;
            [Tooltip("Variation of shift Svx/Fz with load")]
            public float pvx2 = -0.03904f;
            [Tooltip("Relaxation length SigKap0/Fz at Fznom")]
            public float ptx1 = 2.3657f;
            [Tooltip("Variation of SigKap0/Fz with load")]
            public float ptx2 = 1.4112f;
            [Tooltip("Variation of SigKap0/Fz with exponent of load")]
            public float ptx3 = 0.56626f;

            [Header("Combined slip")]
            [Tooltip("Slope factor for combined slip Fx reduction")]
            public float rbx1 = 13.458f;
            [Tooltip("Variation of slope Fx reduction with kappa")]
            public float rbx2 = -11.604f;
            [Tooltip("Shape factor for combined slip Fx reduction")]
            public float rcx1 = 1.1666f;
            [Tooltip("Shift factor for combined slip Fx reduction")]
            public float rhx1 = 0.0040974f;
        }

        [Serializable]
        public class AligningParameters
        {
            [Header("Pure side slip")]
            [Tooltip("Trail slope factor for trail Bpt at Fznom")]
            public float qbz1 = 11.266f;
            [Tooltip("Variation of slope Bpt with load")]
            public float qbz2 = 2.806f;
            [Tooltip("Variation of slope Bpt with load squared")]
            public float qbz3 = -0.586f;
            [Tooltip("Variation of slope Bpt with camber")]
            public float qbz4 = 0.405f;
            [Tooltip("Variation of slope Bpt with absolute camber")]
            public float qbz5 = -0.020833f;
            [Tooltip("Slope factor Br of residual torque Mzr")]
            public float qbz9 = 29.996f;
            [Tooltip("Slope factor Br of residual torque Mzr")]
            public float qbz10 = 0;
            [Tooltip("Shape factor Cpt for pneumatic trail")]
            public float qcz1 = 1.1908f;
            [Tooltip("Peak trail Dpt = Dpt * (Fz / Fznom * R0)")]
            public float qdz1 = 0.11738f;
            [Tooltip("Variation of peak Dpt with load")]
            public float qdz2 = 0.009433f;
            [Tooltip("Variation of peak Dpt with camber")]
            public float qdz3 = 0.13701f;
            [Tooltip("Variation of peak Dpt with camber squared")]
            public float qdz4 = -2.8255f;
            [Tooltip("Peak residual torque Dmr = Dmr / (Fz * R0)")]
            public float qdz6 = -7.047e-4f;
            [Tooltip("Variation of peak factor Dmr with load")]
            public float qdz7 = 1.8184e-4f;
            [Tooltip("Variation of peak factor Dmr with camber")]
            public float qdz8 = 0.15867f;
            [Tooltip("Var. of peak factor Dmr with camber and load")]
            public float qdz9 = 0.02444f;
            [Tooltip("Trail curvature Ept at Fznom")]
            public float qez1 = -2.3346f;
            [Tooltip("Variation of curvature Ept with load")]
            public float qez2 = 1.7478f;
            [Tooltip("Variation of curvature Ept with load squared")]
            public float qez3 = 0;
            [Tooltip("Variation of curvature Ept with sign of Alpha-t")]
            public float qez4 = 0.25f;
            [Tooltip("Variation of Ept with camber and sign Alpha-t")]
            public float qez5 = 2.1345f;
            [Tooltip("Trail horizontal shift Sht at Fznom")]
            public float qhz1 = 2.5437e-4f;
            [Tooltip("Variation of shift Sht with load")]
            public float qhz2 = 3.316e-4f;
            [Tooltip("Variation of shift Sht with camber")]
            public float qhz3 = 0.08772f;
            [Tooltip("Variation of shift Sht with camber and load")]
            public float qhz4 = 0.04964f;
        }

        [Serializable]
        public class RollingCoefficients
        {
            [Tooltip("Rolling resistance torque coefficient")]
            public float qsy1 = 0;
            [Tooltip("Rolling resistance torque depending on Fx")]
            public float qsy2 = 0;
            [Tooltip("Rolling resistance torque depending on speed")]
            public float qsy3 = 0;
            [Tooltip("Rolling resistance torque depending on speed squared")]
            public float qsy4 = 0;
        }

        [Serializable]
        public class OverturningCoefficients
        {
            [Tooltip("Lateral force induced overturning moment")]
            public float qsx1 = 0;
            [Tooltip("Camber induced overturning couple")]
            public float qsx2 = 0;
            [Tooltip("Fy induced overturning couple")]
            public float qsx3 = 0;
        }

        [Serializable]
        public class ScalingCoefficients
        {
            [Tooltip("Scale factor of nominal (rated) load")]
            public float Lfzo = 1;
            [Tooltip("Scale factor of Fx shape factor")]
            public float Lcx = 1;
            [Tooltip("Scale factor of Fx peak friction coefficient")]
            public float Lmux = 1;
            [Tooltip("Scale factor of Fx curvature factor")]
            public float Lex = 1;
            [Tooltip("Scale factor of Fx slip stiffness")]
            public float Lkx = 1;
            [Tooltip("Scale factor of Fx horizontal shift")]
            public float Lhx = 1;
            [Tooltip("Scale factor of Fx vertical shift")]
            public float Lvx = 1;
            [Tooltip("Scale factor of Fy shape factor")]
            public float Lcy = 1;
            [Tooltip("Scale factor of Fy peak friction coefficient")]
            public float Lmuy = 1;
            [Tooltip("Scale factor of Fy curvature factor")]
            public float Ley = 1;
            [Tooltip("Scale factor of Fy cornering stiffness")]
            public float Lky = 1;
            [Tooltip("Scale factor of Fy horizontal shift")]
            public float Lhy = 1;
            [Tooltip("Scale factor of Fy vertical shift")]
            public float Lvy = 1;
            [Tooltip("Scale factor of camber for Fy")]
            public float Lgay = 1;
            [Tooltip("Scale factor of Peak of pneumatic trail")]
            public float Ltr = 1;
            [Tooltip("Scale factor for offset of residual torque")]
            public float Lres = 1;
            [Tooltip("Scale factor of camber for Mz")]
            public float Lgaz = 1;
            [Tooltip("Scale factor of alpha influence on Fx")]
            public float Lxal = 1;
            [Tooltip("Scale factor of alpha influence on Fy")]
            public float Lyka = 1;
            [Tooltip("Scale factor of kappa induced Fy")]
            public float Lvyka = 1;
            [Tooltip("Scale factor of Moment arm of FxL")]
            public float Ls = 1;
            [Tooltip("Scale factor of Relaxation length of Fx")]
            public float Lsgkp = 1;
            [Tooltip("Scale factor of Relaxation length of Fy")]
            public float Lsgal = 1;
            [Tooltip("Scale factor of gyroscopic torque")]
            public float Lgyr = 1;
            [Tooltip("Scale factor of overturning couple")]
            public float Lmx = 1;
            [Tooltip("Scale factor of rolling resistance torque")]
            public float Lmy = 1;
        }


        public enum Mode { Combined, Pure };

        public string name;

        public Transform wheel;
        public Transform mesh;
        public Transform rayPoint;

        public float mass = 1.00f;
        public float inertia = 2.2f;
        public float wheelRadius = 0.5f;
        public float tireWidth;

        [Range(0, 1)]
        public float commandedBrake;
        public SmoothFloat trueBrake = new SmoothFloat(0, new Vector2(0, 1), 0.3f);
        public float maxBrakeTorque;

        public bool debug = false;

        Mesh deformingMesh;
        [Header("Mesh deformation")]
        public List<Vector3> refVertexLine = new List<Vector3>();
        private Vector3[] originalVertices;
        private Vector3[] modifiedVertices;
        private List<ModifiedSegment> tireSegments = new List<ModifiedSegment>();
        public float vertexPrecision = 0.001f;
        public int segmentAmount = 32;
        public Vector3 vertexDirection;
        public Vector3 tireSideDirection;
        public float tireProfile;
        public AnimationCurve tireWallInwardDeformationCurve;
        public AnimationCurve tireWallSideDeformationCurve;

        [Space(10)]
        public bool updateTireVisual = true;

        [Header("Properties")]
        [Tooltip("Bar")]
        public float tirePressure;
        public float tireReturnSpeed;

        public Vector3 compressionAxis;

        public float maxWheelForce;

        [Header("Coefficients")]
        public LateralParameters lateral;
        public LongitudinalParameters longitudinal;
        public AligningParameters align;
        public RollingCoefficients rolling;
        public OverturningCoefficients overturn;
        public ScalingCoefficients scaling;

        [Header("Tire data input")]
        public Mode tireMode;
        public int fittyp = 5;
        public int vxlow = 1;
        [Tooltip("Measurement speed")]
        public float longvl = 1;

        [Space(5)]
        [Tooltip("Tyre vertical stiffness")]
        public float verticalStiffness = 500000;
        [Tooltip("Tyre vertical damping")]
        public float verticalDamping = 50;
        [Tooltip("Low load stiffness e.r.r.")]
        public float breff = 5.0f;
        [Tooltip("Peak value of e.r.r.")]
        public float dreff = 0.5f;
        [Tooltip("High load stiffness e.r.r.")]
        public float freff = 0.050f;
        [Tooltip("Nominal wheel load")]
        public float fnomin = 100000;

        [Space(5)]
        [Tooltip("Minimum valid wheel slip")]
        public float kpumin = -1f;
        [Tooltip("Maximum valid wheel slip")]
        public float kpumax = 1f;

        [Space(5)]
        [Tooltip("Minimum valid slip angle")]
        public float alpmin = -1f;
        [Tooltip("Maximum valid slip angle")]
        public float alpmax = 1f;

        [Space(5)]
        [Tooltip("Minimum valid camber angle")]
        public float cammin = -1f;
        [Tooltip("Maximum valid camber angle")]
        public float cammax = 1f;

        [Space(5)]
        [Tooltip("Minimum allowed wheel load")]
        public float fzmin = 5000;
        [Tooltip("Maximum allowed wheel load")]
        public float fzmax = 400000;

        [Space(5)]
        [Tooltip("Minimum relaxation length time (s)")]
        public float minStretch = 0.1f;
        [Tooltip("Transfer factor from low speed slip to high speed")]
        public float slipfctr = 3f;
        [Tooltip("Tanh function transition sharpness")]
        public float beta = 3f;
        [Tooltip("Low speed lateral tanh function transition sharpness")]
        public float beta2 = 3f;

        [Range(0.01f, 1)]
        public float frictionCoefficient = 1;
        [Range(0.0001f, 1)]
        public float bearingFrictionCoefficient = 0.0012f;

        public float wheelThresholdVelocity = 3.0f;

        [Header("Antiskid")]
        [Range(0, 1)]
        public float antiSkidReleaseSpeed = 0.87f;
        public PIDController antiSkidControl;

        [Space(10)]

        [Range(0, 1)]
        public float angularFrictionMultiplier;

        [Header("Stats")]
        [Range(0, 1)]
        public float suspensionCompressionFactor;
        [Range(0, 1)]
        public float rawCompressionFactor;
        [Range(0, 1)]
        public float tireCompression;
        [Range(0, 1)]
        public float totalCompression;
        public bool groundHit;

        [Space(10)]
        public bool wheelRetractionBraking = false;

        float wheelRotation;
        private float wheelCircumference = 0.00f;

        [Space(5)]
        public float affectedSuspensionForce;
        public float pureSuspensionForce;
        public SmoothFloat suspensionDamper = new SmoothFloat(0, new Vector2(-10000000f, 10000000f), 0.2f, true, SmoothFloat.Direction.Increasing);

        public float compressionVelocity;

        [HideInInspector]
        public Vector3 hitNormal;
        private Vector3 hitPoint;

        public float loadWheelRadius;
        public float effectiveRollingRadius;

        public int totalVertexSize;
        public int segmentSize;

        [Tooltip("Lateral speed")]
        public float Vy;
        [Tooltip("Longitudinal speed")]
        public float Vx;

        public float lateralSlip;
        public float lowLateralSlip;
        public float correctedLateralSlip;
        public float longitudinalSlip;
        public float lowLongitudinalSlip;
        public float correctedLongitudinalSlip;
        public float longitudinalSlipVelocity;

        [Space(5)]
        public float wheelRelativeVelocity;

        [Header("Forces")]
        public float lateralForce;
        public float longitudinalForce;
        public Vector3 moments;
        public float wheelGroundTorque;

        [Space(10)]
        public float wheelMomentOfInertia;
        public float wheelAngularVelocity;
        public float wheelLinearVelocity;
        public float wheelAngularMomentum;
        public float wheelAngularAcceleration;

        public float angularForce;
        public float sideInclination;

        [HideInInspector]
        public float alpha;
        [HideInInspector]
        public float kappa;

        [HideInInspector]
        public float lateralStretched;
        [HideInInspector]
        public float longitudinalStretched;

        [Header("Slips for skidding")]
        [Range(0, 90)]
        public float latSlipPoint;
        public float latMaxForce;
        [Range(0, 100)]
        public float longSlipPoint;
        public float longMaxForce;

        [Space(5)]

        [Range(0, 100)]
        public float realSlip;

        public float brakeTorque;

        Transform skidTrans;
        TrailRenderer skidTrail;


        public void Init(Transform skid)
        {
            if(refVertexLine.Count > 0)
            {
                deformingMesh = mesh.GetComponent<MeshFilter>().mesh;
                deformingMesh.MarkDynamic();
                originalVertices = deformingMesh.vertices;
                modifiedVertices = new Vector3[originalVertices.Length];

                totalVertexSize = originalVertices.Length;
                segmentSize = refVertexLine.Count;

                float segmentStep = 360f / segmentAmount;

                for (int ii = 0; ii < originalVertices.Length; ii++)
                {
                    modifiedVertices[ii] = originalVertices[ii];
                }

                for (int x = 0; x < segmentAmount; x++)
                {
                    List<ModifiedVertex> vertexList = new List<ModifiedVertex>();

                    for (int i = 0; i < originalVertices.Length ; i++)
                    {
                        for (int r = 0; r < refVertexLine.Count; r++)
                        {
                            if (ValueCheck.InRange(refVertexLine[r], originalVertices[i], vertexPrecision))
                            {
                                vertexList.Add(new ModifiedVertex(i, r, originalVertices[i]));
                            }
                        }
                    }

                    tireSegments.Add(new ModifiedSegment(x, vertexList));

                    for (int rr = 0; rr < refVertexLine.Count; rr++)
                    {
                        Vector3 offset = Quaternion.Euler(vertexDirection.normalized * segmentStep) * refVertexLine[rr];
                        refVertexLine[rr] = offset;
                    }
                }
            }

            skidTrans = Instantiate(skid, Vector3.zero, Quaternion.identity);
            skidTrail = skidTrans.GetComponent<TrailRenderer>();
            skidTrail.transform.SetParent(wheel.transform);
            skidTrail.transform.localPosition = Vector3.zero;
            skidTrans.transform.localEulerAngles = new Vector3(90, 0, 0);
            skidTrail.widthMultiplier = tireWidth + 0.2f;

            lateralStretched = minStretch;
            longitudinalStretched = minStretch;

            Mode origTireMode = tireMode;
            tireMode = Mode.Pure;

            for (float i = 0; i < 90; i += 0.01f)
            {
                float force = CalcLateralForce(-i, fzmax, 0);

                if (force >= latMaxForce)
                {
                    latMaxForce = force;
                }
                else
                {
                    latSlipPoint = i;
                    break;
                }
            }

            for (float i = 0; i < 1; i += 0.005f)
            {
                float force = CalcLongitudinalForce(i, fzmax, 0);

                if (force >= longMaxForce)
                {
                    longMaxForce = force;
                }
                else
                {
                    longSlipPoint = i * 100;
                    break;
                }
            }

            tireMode = origTireMode;
        }


        public void FixedUpdate(float suspensionStiffness, float suspensionMaxForce, float suspensionMaxDamping, Transform strut, float suspensionStartPoint, Vector3 suspensionAxis, float overhead, float suspensionDistance, LayerMask hitLayerMask, float maxTotalCompression, float forceMultiplier, float returnSpeed, bool antiSkid)
        {
            loadWheelRadius = wheelRadius - (tireCompression * tireProfile);
            wheelCircumference = loadWheelRadius * Mathf.PI * 2;

            suspensionDamper.Update(SmoothFloat.UpdateType.FixedUpdate);
            trueBrake.Update(SmoothFloat.UpdateType.FixedUpdate);

            RaycastHit hit;
            if (Physics.Raycast(rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint) + (strut.transform.TransformDirection(suspensionAxis.normalized) * -overhead), strut.transform.TransformDirection(suspensionAxis.normalized), out hit, suspensionDistance + overhead, hitLayerMask))
            {
                hitNormal = hit.normal;
                hitPoint = hit.point;

                groundHit = true;

                rawCompressionFactor = Mathf.Clamp01((suspensionDistance - (hit.distance - overhead)) / suspensionDistance);

                affectedSuspensionForce = forceMultiplier * AffectedSuspensionForce(rawCompressionFactor, suspensionStiffness, suspensionMaxForce, suspensionMaxDamping);

                tireCompression = Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(affectedSuspensionForce, 0, suspensionMaxForce + suspensionMaxDamping), 1.01f - (Mathf.Sqrt(tirePressure) / 50)) / (Mathf.Pow(tirePressure / 10f, 0.7f) * (1 - (Mathf.Pow(tireProfile, 0.7f) * 0.3f)) * maxWheelForce));
                totalCompression = Mathf.Clamp01(rawCompressionFactor - (tireCompression * (tireProfile / suspensionDistance)));

                suspensionCompressionFactor = Mathf.Clamp01((((suspensionDistance - (tireCompression * tireProfile)) - (hit.distance - overhead)) / (suspensionDistance - (tireCompression * tireProfile))));

                compressionVelocity = Vector3.Dot(hitNormal.normalized, rb.GetPointVelocity(rayPoint.transform.position));

                affectedSuspensionForce = forceMultiplier * AffectedSuspensionForce(suspensionCompressionFactor, suspensionStiffness, suspensionMaxForce, suspensionMaxDamping);
            }
            else
            {
                hitNormal = Vector3.zero;
                hitPoint = Vector3.zero;
                groundHit = false;

                suspensionCompressionFactor = 0;
                rawCompressionFactor = 0;

                affectedSuspensionForce = 0;

                if (tireCompression > 0)
                {
                    tireCompression -= Time.fixedDeltaTime * tireReturnSpeed;
                }
                else if (tireCompression < 0)
                {
                    tireCompression = 0;
                }

                if (totalCompression > 0)
                {
                    totalCompression -= Time.fixedDeltaTime * returnSpeed;
                }
                else if (totalCompression < 0)
                {
                    totalCompression = 0;
                }

                compressionVelocity = 0;
            }

            Debug.DrawLine(rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint) + (strut.transform.TransformDirection(suspensionAxis.normalized) * -overhead), rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint), Color.red);
            Debug.DrawLine(rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint), rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint) + (strut.transform.TransformDirection(suspensionAxis.normalized) * ((1 - suspensionCompressionFactor) * (suspensionDistance - tireProfile))), Color.blue);
            Debug.DrawLine(rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint) + (strut.transform.TransformDirection(suspensionAxis.normalized) * ((1 - suspensionCompressionFactor) * (suspensionDistance - tireProfile))), rayPoint.transform.position + (strut.transform.TransformDirection(suspensionAxis.normalized) * suspensionStartPoint) + (strut.transform.TransformDirection(suspensionAxis.normalized) * ((1 - suspensionCompressionFactor) * (suspensionDistance - tireProfile))) + (strut.transform.TransformDirection(suspensionAxis.normalized) * ((1 - tireCompression) * tireProfile)), Color.green);

            pureSuspensionForce = Mathf.Pow(suspensionCompressionFactor, suspensionStiffness) * suspensionMaxForce;

            // Tire physics
            sideInclination = Vector3.Dot(rb.transform.TransformDirection(Vector3.right), Vector3.up) * Mathf.Rad2Deg;

            if (wheelRetractionBraking)
            {
                if(Mathf.Abs(wheelAngularVelocity) < 0.5f)
                {
                    trueBrake.ValueChange(0);
                    wheelRetractionBraking = false;
                }
            }

            if (groundHit)
            {
                if (commandedBrake > Mathf.Epsilon)
                {
                    if (antiSkid)
                    {
                        float brakeControl = Mathf.Clamp01(antiSkidReleaseSpeed - Mathf.Abs(wheelRelativeVelocity));

                        if (brakeControl > 0)
                        {
                            trueBrake.ValueChange(Mathf.Clamp01(antiSkidControl.GetThrustFactorFixed(brakeControl)));
                        }
                        else
                        {
                            trueBrake.ValueChange(commandedBrake);
                        }
                    }
                    else
                    {
                        trueBrake.ValueChange(commandedBrake);
                    }
                }
                else
                {
                    if (trueBrake.GetValue() != 0)
                    {
                        trueBrake.ValueChange(0);
                    }
                }
            }
            else
            {
                if (!wheelRetractionBraking)
                {
                    trueBrake.ValueChange(0);
                }
            }

            brakeTorque = trueBrake.smoothValue * ((float)Math.Tanh(beta * wheelAngularVelocity) * maxBrakeTorque);

            if (groundHit)
            {
                Vy = Vector3.Dot(wheel.transform.right, rb.GetPointVelocity(wheel.transform.position));
                Vx = Vector3.Dot(wheel.transform.forward, rb.GetPointVelocity(wheel.transform.position));
                longitudinalSlipVelocity = loadWheelRadius * wheelAngularVelocity - Vx;

                lateralSlip += (Mathf.Clamp(Mathf.Atan2(Vy, Mathf.Abs(Vx)) * Mathf.Rad2Deg, alpmin * Mathf.Rad2Deg, alpmax * Mathf.Rad2Deg) - lateralSlip) * (Time.fixedDeltaTime / lateralStretched);
                lowLateralSlip += (((float)Math.Tanh(beta2 * Vy) * 90f) - lowLateralSlip) * (Time.fixedDeltaTime / lateralStretched);
                longitudinalSlip += (Mathf.Clamp((loadWheelRadius * wheelAngularVelocity - Vx) / Mathf.Abs(Vx), kpumin, kpumax) - longitudinalSlip) * (Time.fixedDeltaTime / longitudinalStretched);
                lowLongitudinalSlip = (((2 * longitudinalSlipVelocity) / (wheelThresholdVelocity + (Mathf.Pow(Vx, 2) / wheelThresholdVelocity))) - lowLongitudinalSlip) * (Time.fixedDeltaTime / longitudinalStretched);

                correctedLongitudinalSlip = ((1 - Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr))) * lowLongitudinalSlip) + (Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr)) * longitudinalSlip);
                correctedLateralSlip = ((1 - Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr))) * lowLateralSlip) + (Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr)) * lateralSlip);

                lateralForce = CalcLateralForce(-(correctedLateralSlip - Mathf.Sin(sideInclination)), Mathf.Clamp(pureSuspensionForce, fzmin, fzmax), 0);
                longitudinalForce = CalcLongitudinalForce(correctedLongitudinalSlip, Mathf.Clamp(pureSuspensionForce, fzmin, fzmax), 0);
                moments = MomentCalc(Mathf.Clamp(pureSuspensionForce, fzmin, fzmax), lateralForce, longitudinalForce, 0, -lateralSlip);

                if (lateralForce != 0)
                {
                    rb.AddForceAtPosition(Vector3.ProjectOnPlane(wheel.transform.TransformDirection(Vector3.left), hitNormal) * lateralForce, hitPoint, ForceMode.Force);
                    Debug.DrawRay(hitPoint, Vector3.ProjectOnPlane(wheel.transform.TransformDirection(Vector3.left), hitNormal) * lateralForce / 100000, Color.yellow);
                }

                if (moments.y != 0)
                {
                    rb.AddForceAtPosition(Vector3.ProjectOnPlane(wheel.transform.TransformDirection(Vector3.forward), hitNormal) * (moments.y - (Convert.ToInt32(groundHit) * Mathf.Min(Mathf.Abs(longitudinalForce), brakeTorque * (loadWheelRadius * Mathf.Sin(Mathf.PI / 2))))), hitPoint, ForceMode.Force);
                    Debug.DrawRay(hitPoint, Vector3.ProjectOnPlane(wheel.transform.TransformDirection(Vector3.forward), hitNormal) * (moments.y - Mathf.Min(Mathf.Abs(longitudinalForce), brakeTorque / (loadWheelRadius * Mathf.Sin(Mathf.PI / 2)))) / 10000, Color.red);
                }

                realSlip = Mathf.Clamp((Mathf.Clamp(Mathf.Abs(correctedLateralSlip) - latSlipPoint, 0, Mathf.Infinity) / (((alpmax * Mathf.Rad2Deg) - latSlipPoint) / 100)) + (Mathf.Clamp01((Mathf.Abs(correctedLongitudinalSlip * 100) - longSlipPoint) / (100 - longSlipPoint)) * 100), 0, 100);
            }
            else
            {
                Vy = 0;
                Vx = 0;

                lateralSlip = 0;
                lowLateralSlip = 0;
                correctedLateralSlip = 0;
                longitudinalSlip = 0;
                lowLongitudinalSlip = 0;
                correctedLateralSlip = 0;
                longitudinalSlipVelocity = 0;

                lateralForce = 0;
                longitudinalForce = 0;
                moments = Vector3.zero;

                realSlip = 0;
            }

            float bearingLoad = pureSuspensionForce + (mass * Mathf.Abs(Physics.gravity.y));
            float bearingFrictionTorque = bearingFrictionCoefficient * (0.25f * bearingLoad);

            correctedLongitudinalSlip = ((1 - Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr))) * lowLongitudinalSlip) + (Mathf.Clamp01(Mathf.Pow(Mathf.Clamp(Vx - wheelThresholdVelocity, 0, 100), slipfctr)) * longitudinalSlip);

            wheelMomentOfInertia = (mass * Mathf.Abs(Physics.gravity.y)) * Mathf.Pow(loadWheelRadius, 2);
            wheelAngularMomentum = wheelMomentOfInertia * wheelAngularVelocity;
            wheelGroundTorque = (loadWheelRadius * ((float)Math.Tanh(beta * -correctedLongitudinalSlip) * Mathf.Abs(longitudinalForce)) * Mathf.Sin(Mathf.PI / 2)) - brakeTorque; //Mathf.Sin(Mathf.PI / 2) can be replaced with force angle
            wheelAngularAcceleration = (wheelGroundTorque - bearingFrictionTorque) / wheelMomentOfInertia;

            wheelLinearVelocity = wheelAngularVelocity * (loadWheelRadius * Mathf.Sin(Mathf.PI / 2));

            wheelAngularVelocity += wheelAngularAcceleration * Time.fixedDeltaTime;
            if(Mathf.Sign(Vx) == 1)
            {
                wheelAngularVelocity = Mathf.Clamp(wheelAngularVelocity, 0, Vx / loadWheelRadius);
            }
            else if(Mathf.Sign(Vx) == -1)
            {
                wheelAngularVelocity = Mathf.Clamp(wheelAngularVelocity, -Vx / loadWheelRadius, 0);
            }

            if (Vx != 0)
            {
                wheelRelativeVelocity = wheelLinearVelocity / Vx;
            }
            else
            {
                wheelRelativeVelocity = 0;
            }

            if (realSlip > Mathf.Epsilon)
            {
                skidTrans.transform.position = hitPoint + (wheel.transform.TransformDirection(Vector3.up) * 0.03f);
                skidTrail.emitting = true;
            }
            else
            {
                skidTrail.emitting = false;
            }

            angularForce = angularFrictionMultiplier * pureSuspensionForce * Mathf.Cos(sideInclination);

            if (mesh != null)
            {
                mesh.transform.Rotate(-wheelAngularVelocity * Mathf.Rad2Deg * Time.fixedDeltaTime, 0, 0, Space.Self);
                wheelRotation = WheelRotationConversion(mesh.transform.localEulerAngles.x, mesh.transform.localEulerAngles.y);
            }

            if (tireSegments.Count > 0)
            {
                foreach (ModifiedSegment seg in tireSegments)
                {
                    modifiedVertices = seg.Update(modifiedVertices, tireCompression, hitNormal, wheelRotation, tireProfile, tireWallInwardDeformationCurve, tireWallSideDeformationCurve, segmentSize, wheelRadius, segmentAmount, tireSideDirection, rayPoint);
                }

                deformingMesh.vertices = modifiedVertices;
                deformingMesh.RecalculateBounds();
            }
        }

        public void WheelRetractionBraking(float brakeInput)
        {
            wheelRetractionBraking = true;

            trueBrake.ValueChange(brakeInput);
        }

        float AffectedSuspensionForce(float factor, float stiffness, float suspensionMaxForce, float suspensionDampingForce)
        {
            float springForce = Mathf.Pow(factor, stiffness) * suspensionMaxForce;
            float damperForce = -compressionVelocity * suspensionDampingForce;

            suspensionDamper.ValueChange(damperForce);

            return Mathf.Clamp((springForce + suspensionDamper.smoothValue), 0, Mathf.Infinity);
        }


        float CalcLateralForce(float alpha, float Fz, float gamma)
        {
            alpha *= Mathf.Deg2Rad;
            gamma *= Mathf.Deg2Rad;

            lateralStretched = Mathf.Max(lateral.pty1 * Mathf.Sin(2 * Mathf.Atan(Fz / (lateral.pty2 * fnomin))) * (1 - lateral.pty3 * Mathf.Abs(gamma)) * wheelRadius * alpha, minStretch);

            float Gyk = 0;
            float SVyk = 0;

            if (tireMode == Mode.Combined)
            {
                Gyk = CalcFg(kappa, alpha, Fz, gamma, false);

                float dfz = (Fz - fnomin) / Fz;
                float Muy = CalcfMu(lateral.pdy1, lateral.pdy2, lateral.pdy3, gamma, scaling.Lmuy, dfz);
                float DVyk = Muy * Fz * (lateral.rvy1 + lateral.rvy2 * dfz + lateral.rvy3 * gamma) * Mathf.Cos(Mathf.Atan(lateral.rvy4 * alpha));
                SVyk = DVyk * Mathf.Sin(lateral.rvy5 * Mathf.Atan(lateral.rvy6 * kappa));
            }
            else if(tireMode == Mode.Pure)
            {
                Gyk = 1;
                SVyk = 0;
            }

            return CalcF(alpha, Fz, gamma, false) * Gyk + SVyk;
        }

        float CalcLongitudinalForce(float kappa, float Fz, float gamma)
        {
            gamma *= Mathf.Deg2Rad;
            float dfz = (Fz - fnomin) / Fz;

            longitudinalStretched = Mathf.Max(Fz * (longitudinal.ptx1 + longitudinal.ptx2 * dfz) * Mathf.Exp(longitudinal.ptx3 * dfz) * (wheelRadius / fnomin) * kappa, minStretch);

            float G = 0;

            if(tireMode == Mode.Combined)
            {
                G = CalcFg(kappa, alpha, Fz, gamma, true);
            }
            else if (tireMode == Mode.Pure)
            {
                G = 1;
            }

            return G * CalcF(kappa, Fz, gamma, true);
        }

        float CalcF(float ka, float Fz, float gamma, bool isX)
        {
            float dfz = (Fz - fnomin) / Fz;

            if (isX)
            {
                float pdx3 = 0;
                float Mux = CalcfMu(longitudinal.pdx1, longitudinal.pdx2, pdx3, gamma, scaling.Lmux, dfz);
                float D = Mux * Fz;
                float C = longitudinal.pcx1 * scaling.Lcx;
                float Kxk = (longitudinal.pkx1 + longitudinal.pkx2 * dfz) * Mathf.Exp(longitudinal.pkx3 * dfz) * Fz * scaling.Lkx;
                float B = Kxk / (C * D);
                float SH = (longitudinal.phx1 + longitudinal.phx2 * dfz) * scaling.Lhx;
                ka += SH;
                float E = (longitudinal.pex1 + longitudinal.pex2 * dfz + longitudinal.pex3 * Mathf.Pow(dfz, 2)) * (1 - longitudinal.pex4 * Mathf.Sign(ka)) * scaling.Lex;
                float SV = Fz * (longitudinal.pvx1 + longitudinal.pvx2* dfz) * scaling.Lvx * scaling.Lmux;

                return (D * Mathf.Sin(C * Mathf.Atan(B * ka - E * (B * ka - Mathf.Atan(B * ka)))) + SV);
            }
            else
            {
                float Muy = (lateral.pdy1 + lateral.pdy2 * dfz) * (1 - lateral.pdy3 * Mathf.Pow(gamma, 2)) * scaling.Lmuy;
                float D = Muy * Fz;
                float C = lateral.pcy1 * scaling.Lcy;
                float Kya = lateral.pky1 * fnomin * Mathf.Sin(lateral.pky4 * Mathf.Atan(Fz / (lateral.pky2 + lateral.pky5 * Mathf.Pow(gamma, 2)) / fnomin / scaling.Lfzo)) * (1 - lateral.pky3 * Mathf.Abs(gamma)) * scaling.Lky;
                float B = Kya / (C * D);
                float Kyg = (lateral.pvy3 + lateral.pvy4 * dfz) * Fz;
                float SHy0 = (lateral.phy1 + lateral.phy2 * dfz) * scaling.Lhy;
                float SVyg = Fz * (lateral.pvy3 + lateral.pvy4 * dfz) * gamma * scaling.Lky * scaling.Lmuy;
                float SHyg = (Kyg * gamma - SVyg) / Kya;
                float SH = SHy0 + SHyg;
                float SVy0 = Fz * (lateral.pvy1 + lateral.pvy2 * dfz) * scaling.Lvy * scaling.Lmuy;
                float SV = SVy0 + SVyg;
                ka += SH;
                float E = (lateral.pey1 + lateral.pey2 * dfz) * (1 - (lateral.pey3 + lateral.pey4 * gamma) * Mathf.Sign(ka)) * scaling.Ley;

                if(E >= 1)
                {
                    Debug.LogWarning("Ey = " + E + " which is greater than or equal to 1");
                }

                return (D * Mathf.Sin(C * Mathf.Atan(B * ka - E * (B * ka - Mathf.Atan(B * ka)))) + SV);
            }
        }

        float CalcFg(float kappa, float alpha, float Fz, float gamma, bool isX)
        {
            float dfz = (Fz - fnomin) / Fz;

            float B = 0;
            float SH = 0;
            float akS = 0;

            if(tireMode != Mode.Combined)
            {
                Debug.LogWarning("Tire mode is not configured for combined slip, please change Tire mode to *Combined*");
                return 1;
            }
            else if(tireMode == Mode.Combined)
            {
                if (isX)
                {
                    B = (longitudinal.rbx1 + 0 * Mathf.Pow(gamma, 2)) * Mathf.Cos(Mathf.Atan(longitudinal.rbx2 * kappa)) * scaling.Lxal;
                    SH = longitudinal.rhx1;
                    akS = alpha + SH;
                }
                else
                {
                    B = (lateral.rby1 + 0 * Mathf.Pow(gamma, 2)) * Mathf.Cos(Mathf.Atan(lateral.rby2 * (alpha - lateral.rby3))) * scaling.Lyka;
                    SH = lateral.rhy1 + lateral.rhy2 * dfz;
                    akS = kappa + SH;
                }

                float C = longitudinal.rhx1;
                float E = longitudinal.pex1 + longitudinal.pex2 * dfz;

                return Mathf.Cos(C * Mathf.Atan(B * akS - E * (B * akS - Mathf.Atan(B * akS)))) / Mathf.Cos(C * Mathf.Atan(B * SH - E * (B * SH - Mathf.Atan(B * SH))));
            }

            return 1;
        }

        float CalcfMu(float PDX1, float PDX2, float PDX3, float gamma, float LMux, float dfz)
        {
            return (PDX1 + PDX2 * dfz) * (1 - PDX3 * Mathf.Pow(gamma, 2));
        }

        Vector3 MomentCalc(float Fz, float Fx, float Fy, float gamma, float alpha)
        {
            Vector3 r = new Vector3();

            //Overturning moment, Mx
            float LVMx = 1;

            r.x = fnomin * Fz * scaling.Lmx * (overturn.qsx1 * LVMx - overturn.qsx2 * gamma + overturn.qsx3 * Fy / fnomin);

            //Rolling resistance moment, My
            float dfz = (Fz - fnomin) / Fz;

            if(fittyp == 5)
            {
                r.y = -wheelRadius * fnomin * scaling.Lmy * (rolling.qsy1 + rolling.qsy2 * Fx / fnomin + rolling.qsy3 * Mathf.Abs(Vx / longvl) + rolling.qsy4 * Mathf.Pow(Vx / longvl, 4));
            }
            else if(rolling.qsy1 == 0 && rolling.qsy2 == 0)
            {
                float Kx = (longitudinal.pkx1 + longitudinal.pkx2 * dfz) * Mathf.Exp(longitudinal.pkx3 * dfz) * Fz * scaling.Lkx;
                float SVx = Fz * (longitudinal.pvx1 + longitudinal.pvx2 * dfz) * scaling.Lvx * scaling.Lmux;
                float SHx = (longitudinal.phx1 + longitudinal.phx2 * dfz) * scaling.Lhx;

                r.y = wheelRadius * (SVx + Kx * SHx);
            }

            //Self aligning moment, Mz
            float gz = gamma * scaling.Lgaz;
            float SHt = align.qhz1 + align.qhz2 * dfz + (align.qhz3 + align.qhz4 * dfz) * gz;
            float at = alpha + SHt;

            float Bt = (align.qbz1 + align.qbz2 * dfz + align.qbz3 * Mathf.Pow(dfz, 2)) * (1 + align.qbz4 * gz + align.qbz5 * Mathf.Abs(gz)) * scaling.Lky / scaling.Lmuy;

            float Ct = align.qcz1;
            float Dt = Fz * (align.qdz1 + align.qdz2 * dfz) * (1 + align.qdz3 * gz + align.qdz4 * Mathf.Pow(gz, 2)) * wheelRadius / fnomin * scaling.Ltr;

            float Et = (align.qez1 + align.qez2 * dfz + align.qez3 * Mathf.Pow(dfz, 2)) * (1 + (align.qez4 + align.qez5 * gz) * 2 / Mathf.PI * Mathf.Atan(Bt * Ct * at));
            if(Et > 1)
            {
                Debug.LogWarning("Et = " + Et + " which is greater than one.");
            }

            float t = Dt * Mathf.Cos(Ct * Mathf.Atan(Bt * at - Et * (Bt * at - Mathf.Atan(Bt * at)))) * Mathf.Cos(alpha);

            //Residual moment, Mzr
            float SHy = (lateral.phy1 + lateral.phy2 * dfz) * scaling.Lhy;
            float SVy = Fz * (lateral.pvy1 + lateral.pvy2 * dfz) * scaling.Lvy * scaling.Lmuy;
            float Ky = lateral.pky1 * fnomin * Mathf.Sign(lateral.pky4 * Mathf.Atan(Fz / (lateral.pky2 + lateral.pky5 * Mathf.Pow(gamma, 2)) / fnomin / scaling.Lfzo)) * (1 - lateral.pky3 * Mathf.Abs(gamma)) * scaling.Lky;

            float SHf = SHy + SVy / Ky;
            float ar = alpha + SHf;


            float Muy = (lateral.pdy1 + lateral.pdy2 * dfz) * (1 - lateral.pdy3 * Mathf.Pow(gamma, 2)) * scaling.Lmuy;
            float Dy = Muy * Fz;
            float Cy = lateral.pcy1 * scaling.Lcy;
            float By = Ky / (Cy * Dy);
            float Br = align.qbz9 * scaling.Lky / scaling.Lmuy + align.qbz10 * By * Cy;
            float Cr = 1;
            float Dr = Fz * ((align.qdz6 + align.qdz7 * dfz) * scaling.Lres + (align.qdz8 + align.qdz9 * dfz) * gz) * wheelRadius * scaling.Lmuy;
            float Mzr = Dr * Mathf.Cos(Cr * Mathf.Atan(Br * ar)) * Mathf.Cos(alpha);

            r.z = -t * Fy + Mzr;

            return r;
        }


        float WheelRotationConversion(float rotation, float rotationDerivative)
        {
            if(rotationDerivative == 0)
            {
                if(rotation >= 270f)
                {
                    return -rotation + 360f;
                }
                else if(rotation <= 90f)
                {
                    return -rotation + 360f;
                }
            }
            else
            {
                if(rotation >= 270f)
                {
                    return rotation - 180f;
                }
                else if(rotation <= 90f)
                {
                    return rotation + 180f;
                }
            }

            return 0;
        }
    }

    [Serializable]
    public class GearDoor
    {
        public string name;

        public Transform door;
        public Vector3 openingAxis;
        public Vector3 defaultRotation;
        public float openingAmount;
        public float defaultAngle;
        public FluctuatingCurve travelCurve;
        public float openingTime;
        public int state = 3;
        float openTimer;


        public void Init()
        {
            if(state == 3)
            {
                door.transform.localEulerAngles = defaultRotation + openingAxis.normalized * (defaultAngle + openingAmount);
            }
            else if(state == 0)
            {
                door.transform.localEulerAngles = defaultRotation + openingAxis.normalized * defaultAngle;
            }
        }

        public void Update()
        {
            if (state == 2)
            {
                openTimer += Time.deltaTime / openingTime;
                door.transform.localEulerAngles = defaultRotation + openingAxis.normalized * (defaultAngle + (travelCurve.Evaluate(openTimer) * openingAmount));

                if (openTimer >= 1)
                {
                    state = 3;
                    openTimer = 0;
                }
            }
            else if (state == 1)
            {
                openTimer += Time.deltaTime / openingTime;
                door.transform.localEulerAngles = defaultRotation + openingAxis.normalized * (defaultAngle + ((1 - travelCurve.Evaluate(openTimer)) * openingAmount));

                if (openTimer >= 1)
                {
                    state = 0;
                    openTimer = 0;
                }
            }
        }

        public void SwitchState()
        {
            if (state == 3)
            {
                state = 1;
                openTimer = 0;
            }
            else if (state == 0)
            {
                state = 2;
                openTimer = 0;
            }
        }
    }

    [Serializable]
    public class MainGear
    {
        public string name;

        public Wheel[] wheels;

        public PIDController damperPID;

        public Transform strut;
        public Transform rayPoint;
        public float suspensionDistance;
        private float origSuspensionDistance;
        public float overhead;
        public float suspensionMaxForce;
        public float suspensionDampingForce;
        public float suspensionStiffness = 0.7f;
        public Vector3 suspensionAxis;
        public Vector3 compressionAxis;
        public float suspensionStartPoint;
        public LayerMask hitTestLayerMask;
        [Tooltip("m/s")]
        public float suspensionReturnSpeed;

        [Header("Retraction")]
        public int currentState;
        public Transform gearPivot;
        public Vector3 retractionAxis;
        public float gearRetractionAmount;
        public float gearDownAngle;
        public FluctuatingCurve gearAngleCurve;
        public float gearRetractionTime;
        int gearState = 3;
        float gearRetractionTimer;
        public GearDoor gearDoor;

        [Space(5)]
        [Range(0, 1)]
        public float wheelBrakeOnRetraction = 0.05f;

        [Space(5)]

        public Transform coverPlate;
        public Vector3 defaultCoverPlateRotation;
        public float coverPlateMovement;
        public Vector3 coverPlateAxis;

        public Transform lowerArm;
        public Transform upperArm;
        public Transform upperArmConnectionPoint;
        public Vector3 lowerArmDefaultRotation;
        public float lowerArmMovement;
        public Vector3 lowerArmAxis;


        [Header("Stats")]
        public bool onGround;
        [Range(0, 1)]
        public float suspensionCompression;
        [Range(0, 1)]
        public float maxCompression;
        [Range(0, 1)]
        public float maxRawCompression;
        public float totalCompression;
        public float suspensionForce;
        float maxAffectedSuspensionForce;
        public Vector3 suspensionVelo;
        public Vector3 forcePosition;
        public Vector3 forceNormal;
        Vector3 localVelo;
        float damperForce;
        public float compressionVelocity;

        Vector3 origStrutPos;


        public void Init(Transform skid)
        {
            origStrutPos = strut.transform.localPosition;

            gearDoor.Init();
            currentState = 3;
            gearRetractionTimer = 1;

            foreach(Wheel wheel in wheels)
            {
                wheel.Init(skid);
            }

            origSuspensionDistance = suspensionDistance;
        }

        public void FixedUpdate(bool antiSkid)
        {
            if (gearState != 0)
            {
                maxCompression = 0;
                totalCompression = 0;
                maxRawCompression = 0;
                suspensionForce = 0;
                forcePosition = Vector3.zero;
                forceNormal = Vector3.zero;
                onGround = false;

                foreach (Wheel wheel in wheels)
                {
                    if (maxCompression < wheel.totalCompression)
                    {
                        maxCompression = wheel.totalCompression;
                    }

                    if (maxAffectedSuspensionForce < wheel.affectedSuspensionForce)
                    {
                        maxAffectedSuspensionForce = wheel.affectedSuspensionForce;
                    }

                    if (maxRawCompression < wheel.rawCompressionFactor)
                    {
                        maxRawCompression = wheel.rawCompressionFactor;
                    }

                    totalCompression += wheel.suspensionCompressionFactor;

                    if (wheel.groundHit)
                    {
                        onGround = true;
                    }
                }

                foreach (Wheel wheel in wheels)
                {
                    float forceDistribution = 0;
                    if (wheel.suspensionCompressionFactor != 0)
                    {
                        forceDistribution = wheel.suspensionCompressionFactor / totalCompression;
                    }

                    if (wheel.rawCompressionFactor == maxRawCompression)
                    {
                        wheel.FixedUpdate(suspensionStiffness, suspensionMaxForce, suspensionDampingForce, strut, suspensionStartPoint, suspensionAxis, overhead, suspensionDistance, hitTestLayerMask, 0, forceDistribution, suspensionReturnSpeed, antiSkid);
                    }
                    else
                    {
                        wheel.FixedUpdate(suspensionStiffness, suspensionMaxForce, suspensionDampingForce, strut, suspensionStartPoint, suspensionAxis, overhead, suspensionDistance, hitTestLayerMask, maxRawCompression, forceDistribution, suspensionReturnSpeed, antiSkid);
                    }

                    forcePosition -= wheel.rayPoint.transform.localPosition * forceDistribution;
                    forcePosition.y = 0;
                    forcePosition.z = 0;

                    forceNormal += wheel.hitNormal;

                    suspensionForce += wheel.affectedSuspensionForce;
                }

                foreach (Wheel wheel in wheels)
                {
                    if (maxCompression < wheel.totalCompression)
                    {
                        maxCompression = wheel.totalCompression;
                    }

                    if (maxAffectedSuspensionForce < wheel.affectedSuspensionForce)
                    {
                        maxAffectedSuspensionForce = wheel.affectedSuspensionForce;
                    }

                    if (maxRawCompression < wheel.rawCompressionFactor)
                    {
                        maxRawCompression = wheel.rawCompressionFactor;
                    }

                    totalCompression += wheel.suspensionCompressionFactor;

                    if (wheel.groundHit)
                    {
                        onGround = true;
                    }
                }

                strut.transform.localPosition = origStrutPos - (Mathf.Clamp01(maxCompression) * (suspensionAxis.normalized * suspensionDistance));

                forceNormal /= wheels.Length;

                suspensionVelo = rb.GetPointVelocity(rayPoint.transform.position);
                if (onGround)
                {
                    compressionVelocity = Vector3.Dot(compressionAxis.normalized, suspensionVelo);
                }
                else
                {
                    compressionVelocity = 0;
                }

                Debug.DrawRay(strut.transform.position + forcePosition, strut.transform.TransformDirection(-suspensionAxis.normalized) * 2, Color.cyan);
                rb.AddForceAtPosition(forceNormal.normalized * suspensionForce, strut.transform.position + forcePosition);
            }
        }

        public void Update()
        {
            gearDoor.Update();

            if (gearState == 2)
            {
                gearRetractionTimer += Time.deltaTime / gearRetractionTime;
                gearPivot.transform.localEulerAngles = retractionAxis.normalized * (gearDownAngle + (gearAngleCurve.Evaluate(gearRetractionTimer) * gearRetractionAmount));

                if (gearRetractionTimer >= 1)
                {
                    gearState = 3;
                    gearRetractionTimer = 1;
                }
            }
            else if (gearState == 1)
            {
                gearRetractionTimer -= Time.deltaTime / gearRetractionTime;
                gearPivot.transform.localEulerAngles = retractionAxis.normalized * (gearDownAngle + (gearAngleCurve.Evaluate(gearRetractionTimer) * gearRetractionAmount));

                if (gearRetractionTimer <= 0)
                {
                    gearState = 0;
                    gearRetractionTimer = 0;
                }
            }

            coverPlate.transform.localEulerAngles = defaultCoverPlateRotation + (coverPlateAxis.normalized * (gearRetractionTimer * coverPlateMovement));
            upperArm.transform.LookAt(upperArmConnectionPoint);
            lowerArm.transform.localEulerAngles = lowerArmDefaultRotation + (lowerArmAxis.normalized * ((1 - gearRetractionTimer) * lowerArmMovement));
        }

        public float ClampRotation(float value)
        {
            if (value > 180f)
            {
                return value - 360f;
            }
            else
            {
                return value;
            }
        }

        public IEnumerator GearUp()
        {
            currentState = 1;

            foreach(Wheel wh in wheels)
            {
                wh.WheelRetractionBraking(wheelBrakeOnRetraction);
            }

            gearDoor.SwitchState();

            yield return new WaitUntil(() => gearDoor.state == 3);

            gearState = 1;
            gearRetractionTimer = 1;

            yield return new WaitUntil(() => gearState == 0);

            gearDoor.SwitchState();

            yield return new WaitUntil(() => gearDoor.state == 0);

            currentState = 0;
        }

        public IEnumerator GearDown()
        {
            currentState = 2;

            gearDoor.SwitchState();

            yield return new WaitUntil(() => gearDoor.state == 3);

            gearState = 2;
            gearRetractionTimer = 0;

            yield return new WaitUntil(() => gearState == 3);

            gearDoor.SwitchState();

            yield return new WaitUntil(() => gearDoor.state == 0);

            currentState = 3;
        }
    }

    [Serializable]
    public class FrontGear
    {
        public Wheel[] wheels;

        public PIDController damperPID;

        public Transform strut;
        public Transform rayPoint;
        public float suspensionDistance;
        private float origSuspensionDistance;
        public float overhead;
        public float suspensionMaxForce;
        public float suspensionDampingForce;
        public SmoothFloat suspensionDamper = new SmoothFloat(0, new Vector2(-10000000f, 10000000f), 0.1f, true, SmoothFloat.Direction.Increasing);
        public float suspensionStiffness = 0.7f;
        public Vector3 suspensionAxis;
        public Vector3 compressionAxis;
        public float suspensionStartPoint;
        public LayerMask hitTestLayerMask;
        [Tooltip("m/s")]
        public float suspensionReturnSpeed;

        [Space(10)]

        public bool hasSteering = false;
        public Vector3 steerAxis;
        public float steerAngleLimit;

        [Header("Rudder deflection")]
        public float rudderSteerLimitSpeed = 130;
        public float rudderSteerLimitAngle = 6;
        public AnimationCurve rudderSteerCurve;

        [Header("Retraction")]
        public int currentState;
        public Transform gearPivot;
        public Vector3 retractionAxis;
        public float gearRetractionAmount;
        public float gearDownAngle;
        public FluctuatingCurve gearAngleCurve;
        public float gearRetractionTime;
        int gearState = 3;
        float gearRetractionTimer;
        public GearDoor[] frontDoors;
        public GearDoor[] rearDoors;

        [Space(5)]

        [Header("Suspension arms")]
        public Transform frontSuspensionArms;
        public Transform frontSusLowerArm;
        public Transform frontSusLowerArmTarget;
        public Transform frontSusUpperArm;
        public Transform frontSusUpperArmTarget;

        public Transform lowerLinkArm;
        public Vector3 defaultLowerLinkArmRotation;
        public Transform upperLinkArm;
        public Vector3 defaultUpperLinkArmRotation;
        public Vector3 linkArmAxis;
        public float linkArmRotationMultiplier;
        public Transform linkArmConnectionPoint;


        [Header("Stats")]
        public bool onGround;
        [Range(0, 1)]
        public float suspensionCompression;
        [Range(0, 1)]
        public float maxCompression;
        [Range(0, 1)]
        public float maxRawCompression;
        public float totalCompression;
        public float compressionLength;
        public float suspensionForce;
        float maxAffectedSuspensionForce;
        public Vector3 suspensionVelo;
        public Vector3 forcePosition;
        public Vector3 forceNormal;
        Vector3 localVelo;
        float damperForce;
        public float compressionVelocity;
        public SmoothFloat currentSteering = new SmoothFloat(0, new Vector2(-85, 85), 0.3f);

        Vector3 origStrutPos;


        public void Init(Transform skid)
        {
            origStrutPos = strut.transform.localPosition;

            foreach(GearDoor fgrd in frontDoors)
            {
                fgrd.Init();
            }

            foreach (GearDoor rgrd in rearDoors)
            {
                rgrd.Init();
            }

            currentState = 3;
            gearRetractionTimer = 1;

            foreach(Wheel wheel in wheels)
            {
                wheel.Init(skid);
            }

            origSuspensionDistance = suspensionDistance;
        }

        public void FixedUpdate()
        {
            if(gearState != 0)
            {
                maxCompression = 0;
                totalCompression = 0;
                maxRawCompression = 0;
                suspensionForce = 0;
                forcePosition = Vector3.zero;
                forceNormal = Vector3.zero;
                onGround = false;

                float lateralTireForce = 0;

                foreach (Wheel wheel in wheels)
                {
                    if (maxCompression < wheel.totalCompression)
                    {
                        maxCompression = wheel.totalCompression;
                    }

                    if (maxAffectedSuspensionForce < wheel.affectedSuspensionForce)
                    {
                        maxAffectedSuspensionForce = wheel.affectedSuspensionForce;
                    }

                    if(maxRawCompression < wheel.rawCompressionFactor)
                    {
                        maxRawCompression = wheel.rawCompressionFactor;
                    }

                    totalCompression += wheel.suspensionCompressionFactor;

                    if (wheel.groundHit)
                    {
                        onGround = true;
                    }
                }

                foreach (Wheel wheel in wheels)
                {
                    float forceDistribution = 0;
                    if (wheel.suspensionCompressionFactor != 0)
                    {
                        forceDistribution = wheel.suspensionCompressionFactor / totalCompression;
                    }

                    if (wheel.rawCompressionFactor == maxRawCompression)
                    {
                        wheel.FixedUpdate(suspensionStiffness, suspensionMaxForce, suspensionDampingForce, strut, suspensionStartPoint, suspensionAxis, overhead, suspensionDistance, hitTestLayerMask, 0, forceDistribution, suspensionReturnSpeed, false);
                    }
                    else
                    {
                        wheel.FixedUpdate(suspensionStiffness, suspensionMaxForce, suspensionDampingForce, strut, suspensionStartPoint, suspensionAxis, overhead, suspensionDistance, hitTestLayerMask, maxRawCompression, forceDistribution, suspensionReturnSpeed, false);
                    }

                    forcePosition -= wheel.rayPoint.transform.localPosition * forceDistribution;
                    forcePosition.y = 0;
                    forcePosition.z = 0;

                    forceNormal += wheel.hitNormal;

                    suspensionForce += wheel.affectedSuspensionForce;
                    lateralTireForce += wheel.lateralForce;
                }

                foreach (Wheel wheel in wheels)
                {
                    if (maxCompression < wheel.totalCompression)
                    {
                        maxCompression = wheel.totalCompression;
                    }

                    if (maxAffectedSuspensionForce < wheel.affectedSuspensionForce)
                    {
                        maxAffectedSuspensionForce = wheel.affectedSuspensionForce;
                    }

                    if (maxRawCompression < wheel.rawCompressionFactor)
                    {
                        maxRawCompression = wheel.rawCompressionFactor;
                    }

                    totalCompression += wheel.suspensionCompressionFactor;

                    if (wheel.groundHit)
                    {
                        onGround = true;
                    }
                }

                strut.transform.localPosition = origStrutPos - (Mathf.Clamp01(maxCompression) * (suspensionAxis.normalized * suspensionDistance));

                forceNormal /= wheels.Length;

                suspensionVelo = rb.GetPointVelocity(rayPoint.transform.position);
                if (onGround)
                {
                    compressionVelocity = Vector3.Dot(compressionAxis.normalized, suspensionVelo);
                }
                else
                {
                    compressionVelocity = 0;
                }

                compressionLength = totalCompression * suspensionDistance;

                Debug.DrawRay(strut.transform.position + forcePosition, strut.transform.TransformDirection(-suspensionAxis.normalized) * 2, Color.cyan);
                rb.AddForceAtPosition(forceNormal.normalized * suspensionForce, strut.transform.position + forcePosition, ForceMode.Force);
            }
        }

        public void Update()
        {
            foreach(GearDoor fgrd in frontDoors)
            {
                fgrd.Update();
            }
            foreach(GearDoor rgrd in rearDoors)
            {
                rgrd.Update();
            }

            if (hasSteering)
            {
                currentSteering.Update(SmoothFloat.UpdateType.Update);
                strut.transform.localEulerAngles = steerAxis.normalized * currentSteering.smoothValue;
            }

            if (gearState == 2)
            {
                gearRetractionTimer += Time.deltaTime / gearRetractionTime;
                gearPivot.transform.localEulerAngles = retractionAxis.normalized * (gearDownAngle + (gearAngleCurve.Evaluate(gearRetractionTimer) * gearRetractionAmount));

                if (gearRetractionTimer >= 1)
                {
                    gearState = 3;
                    gearRetractionTimer = 1;
                }
            }
            else if (gearState == 1)
            {
                gearRetractionTimer -= Time.deltaTime / gearRetractionTime;
                gearPivot.transform.localEulerAngles = retractionAxis.normalized * (gearDownAngle + (gearAngleCurve.Evaluate(gearRetractionTimer) * gearRetractionAmount));

                if (gearRetractionTimer <= 0)
                {
                    gearState = 0;
                    gearRetractionTimer = 0;
                }
            }

            frontSuspensionArms.transform.localEulerAngles = new Vector3(0, 0, currentSteering.smoothValue);
            frontSusLowerArm.transform.LookAt(frontSusLowerArmTarget);
            frontSusUpperArm.transform.LookAt(frontSusUpperArmTarget);

            lowerLinkArm.transform.localEulerAngles = defaultLowerLinkArmRotation + (linkArmAxis.normalized * (((1 - gearRetractionTimer) * -gearRetractionAmount) * linkArmRotationMultiplier));
            upperLinkArm.transform.LookAt(linkArmConnectionPoint);
        }

        public void SetSteering(float value, SteerMode mode, float speed)
        {
            if (hasSteering)
            {
                if(mode == SteerMode.NoseWheel)
                {
                    currentSteering.ValueChange(value * steerAngleLimit);
                }
                else if(mode == SteerMode.Stabilizer)
                {
                    currentSteering.ValueChange(value * (rudderSteerCurve.Evaluate(speed / rudderSteerLimitSpeed) * rudderSteerLimitAngle));
                }
            }
        }

        public float ClampRotation(float value)
        {
            if (value > 180f)
            {
                return value - 360f;
            }
            else
            {
                return value;
            }
        }

        public IEnumerator GearUp()
        {
            currentState = 1;

            foreach (Wheel wh in wheels)
            {
                wh.WheelRetractionBraking(1);
            }

            foreach (GearDoor fgrd in frontDoors)
            {
                fgrd.SwitchState();
            }

            yield return new WaitUntil(() => frontDoors[0].state == 3);

            gearState = 1;
            gearRetractionTimer = 1;

            yield return new WaitUntil(() => gearState == 0);

            foreach (GearDoor fgrd in frontDoors)
            {
                fgrd.SwitchState();
            }

            foreach (GearDoor rgrd in rearDoors)
            {
                rgrd.SwitchState();
            }

            yield return new WaitUntil(() => frontDoors[0].state == 0);
            yield return new WaitUntil(() => rearDoors[0].state == 0);

            currentState = 0;
        }

        public IEnumerator GearDown()
        {
            currentState = 2;

            foreach (GearDoor fgrd in frontDoors)
            {
                fgrd.SwitchState();
            }

            foreach (GearDoor rgrd in rearDoors)
            {
                rgrd.SwitchState();
            }

            yield return new WaitUntil(() => frontDoors[0].state == 3);
            yield return new WaitUntil(() => rearDoors[0].state == 3);

            gearState = 2;
            gearRetractionTimer = 0;

            yield return new WaitUntil(() => gearState == 3);

            foreach (GearDoor fgrd in frontDoors)
            {
                fgrd.SwitchState();
            }

            yield return new WaitUntil(() => frontDoors[0].state == 0);

            currentState = 3;
        }
    }

    [Serializable]
    public class Airfoil
    {
        [Serializable]
        public class LiftPoint
        {
            public Transform localLeadingPoint;
            public Transform localTrailingPoint;


            [Header("Stats")]
            public Vector3 localPoint;
            public Vector3 globalPoint;
            [Range(0, 1)]
            public float centerOfPressure;
            public Vector3 chordDirection;
            public float chordLength;
            public float distanceFromCenter;
            public float angleOfAttack;
            public float currentLift;
            public float currentDrag;
            public float currentMoment;
            public float liftCoefficient;
            public float dragCoefficient;
            public float momentCoefficient;


            public void Update(Airfoil afRef)
            {
                if (momentCoefficient != 0 && liftCoefficient != 0)
                {
                    centerOfPressure = 0.25f - momentCoefficient / liftCoefficient;
                }
                else
                {
                    centerOfPressure = 0.25f;
                }
                chordLength = Vector3.Distance(localLeadingPoint.transform.localPosition, localTrailingPoint.transform.localPosition);
                chordDirection = (localTrailingPoint.transform.localPosition - localLeadingPoint.transform.localPosition).normalized;
                localPoint = localLeadingPoint.transform.localPosition + (chordDirection * (chordLength * centerOfPressure));
                globalPoint = localLeadingPoint.TransformPoint(localPoint);
                distanceFromCenter = Vector3.Distance(system.fuselage.transform.position, globalPoint);
            }

            public float GetFraction(float totalChord)
            {
                return chordLength / totalChord;
            }
        }


        public string name;
        public LiftPoint[] liftPoints;
        public string airfoilDataPath;
        public AnimationCurve liftCoefficientCurve;
        public AnimationCurve dragCoefficientCurve;
        public AnimationCurve momentCoefficientCurve;
        public Vector3 liftAxis;
        public float maxAreaSqrFt;
        public Transform liftPointsParent;


        [Header("Stats")]
        public float totalChordLength;
        public float airfoilLift;
        public float airfoilDrag;
        public float liftToDragRatio;
        public float load;



        public void Init()
        {
            totalChordLength = 0;
            foreach(LiftPoint lp in liftPoints)
            {
                lp.Update(this);
                totalChordLength += lp.chordLength;
            }

            if(airfoilDataPath != "")
            {
                string[] lines;
                string path = Application.persistentDataPath + airfoilDataPath;

                StreamReader reader = new StreamReader(path);
                lines = reader.ReadToEnd().Split('\n');
                reader.Close();

                AnimationCurve clCurve = new AnimationCurve();
                AnimationCurve cdCurve = new AnimationCurve();
                AnimationCurve cmCurve = new AnimationCurve();

                float alpha;
                bool startReading = false;
                foreach (string str in lines)
                {
                    if (startReading)
                    {
                        if (str.Length == 33)
                        {
                            alpha = float.Parse(str.Substring(0, 6).Trim());
                            clCurve.AddKey(new Keyframe(alpha, float.Parse(str.Substring(6, 9).Trim())));
                            cdCurve.AddKey(new Keyframe(alpha, float.Parse(str.Substring(16, 9).Trim())));
                            cmCurve.AddKey(new Keyframe(alpha, float.Parse(str.Substring(25, 9).Trim())));
                        }
                    }

                    if (str.Contains("alpha cl cd cm:"))
                    {
                        startReading = true;
                    }
                }

                liftCoefficientCurve = clCurve;
                dragCoefficientCurve = cdCurve;
                momentCoefficientCurve = cmCurve;
            }
        }

        public void Update(float airDensity, float alteredAngleOfAttack, int[] points, Vector3 relativeVelocity)
        {
            airfoilLift = 0;
            airfoilDrag = 0;

            float Vy = Vector3.Dot(liftPoints[0].localLeadingPoint.transform.up, relativeVelocity + (relativeVelocity - rb.GetPointVelocity(liftPoints[0].globalPoint)));
            float Vx = Vector3.Dot(liftPoints[0].localLeadingPoint.transform.forward, relativeVelocity + (relativeVelocity - rb.GetPointVelocity(liftPoints[0].globalPoint)));

            Vector3 localVelocity = liftPoints[0].localLeadingPoint.InverseTransformDirection(relativeVelocity);
            Vector3 slipDir = Vector3.zero;
            Vector3 crossDir = Vector3.zero;
            float alpha = 0;

            if (liftAxis.x != 0)
            {
                alpha = Mathf.Atan2(-localVelocity.x, localVelocity.y);
                slipDir = Vector3.ProjectOnPlane(relativeVelocity.normalized, liftPoints[0].localLeadingPoint.transform.TransformDirection(Vector3.forward));
                crossDir = Vector3.forward;
            }
            else if (liftAxis.y != 0)
            {
                alpha = Mathf.Atan2(-localVelocity.y, localVelocity.z);
                slipDir = Vector3.ProjectOnPlane(relativeVelocity.normalized, liftPoints[0].localLeadingPoint.transform.TransformDirection(Vector3.right));
                crossDir = Vector3.right;
            }

            for (int i = 0; i < liftPoints.Length; i++)
            {
                float Va = Vector3.Dot(liftPoints[i].localLeadingPoint.transform.forward, rb.angularVelocity) * liftPoints[i].distanceFromCenter;
               
                float liftDirectionMoment = 0;

                if(Vx != 0)
                {
                    liftDirectionMoment = Mathf.Atan(Va / Vx) * Mathf.Rad2Deg;
                }

                if (points.Length != 0)
                {
                    for (int x = 0; x < points.Length; x++)
                    {
                        if (i == points[x])
                        {
                            liftPoints[i].angleOfAttack = (alpha * Mathf.Rad2Deg) + alteredAngleOfAttack + liftDirectionMoment;
                        }
                        else
                        {
                            liftPoints[i].angleOfAttack = (alpha * Mathf.Rad2Deg) + liftDirectionMoment;
                        }
                    }
                }
                else
                {
                    liftPoints[i].angleOfAttack = (alpha * Mathf.Rad2Deg) + alteredAngleOfAttack + liftDirectionMoment;
                }

                liftPoints[i].liftCoefficient = liftCoefficientCurve.Evaluate(liftPoints[i].angleOfAttack);
                liftPoints[i].dragCoefficient = dragCoefficientCurve.Evaluate(liftPoints[i].angleOfAttack);
                liftPoints[i].momentCoefficient = momentCoefficientCurve.Evaluate(liftPoints[i].angleOfAttack);

                liftPoints[i].currentLift = liftPoints[i].GetFraction(totalChordLength) * (liftPoints[i].liftCoefficient * ((airDensity * Mathf.Pow(relativeVelocity.magnitude, 2)) / 2) * maxAreaSqrFt);
                liftPoints[i].currentDrag = liftPoints[i].GetFraction(totalChordLength) * (liftPoints[i].dragCoefficient * ((airDensity * Mathf.Pow(relativeVelocity.magnitude, 2)) / 2) * maxAreaSqrFt);
                liftPoints[i].currentMoment = liftPoints[i].GetFraction(totalChordLength) * (liftPoints[i].momentCoefficient * ((airDensity * Mathf.Pow(relativeVelocity.magnitude, 2)) / 2) * maxAreaSqrFt);

                liftPoints[i].Update(this);

                Vector3 liftDir = Vector3.Cross(slipDir, liftPoints[i].localLeadingPoint.transform.TransformDirection(crossDir));

                Debug.DrawLine(liftPoints[i].globalPoint, liftPoints[i].globalPoint + liftDir * liftPoints[i].currentLift / 600, Color.blue);
                Debug.DrawLine(liftPoints[i].globalPoint + liftDir * liftPoints[i].currentLift / 600, (liftPoints[i].globalPoint + liftDir * liftPoints[i].currentLift / 600) + liftPoints[i].localLeadingPoint.transform.TransformDirection(-localVelocity.normalized) * liftPoints[i].currentDrag / 400, Color.red);

                rb.AddForceAtPosition(liftDir * liftPoints[i].currentLift, liftPoints[i].globalPoint);
                rb.AddForceAtPosition(liftPoints[i].localLeadingPoint.transform.TransformDirection(-localVelocity.normalized) * liftPoints[i].currentDrag, liftPoints[i].globalPoint);

                airfoilLift += liftPoints[i].currentLift;
                airfoilDrag += liftPoints[i].currentDrag;
            }

            liftToDragRatio = airfoilLift / airfoilDrag;
            load = airfoilLift / (rb.mass * Mathf.Abs(Physics.gravity.y));
        }
    }

    [Serializable]
    public class ControlSurfaceTwoWay
    {
        public string name;

        public AnimationCurve deflectionCurve;
        public float maxSurfaceAoAChange;

        public Transform obj;
        public SmoothFloat angle;
        public Vector3 axis;
        [Range(-1, 1)]
        public float input;
        Vector3 originalAngle;


        public void Init()
        {
            originalAngle = obj.transform.localEulerAngles;
        }

        public void FixedUpdate()
        {
            angle.Update(SmoothFloat.UpdateType.FixedUpdate);

            if (input > 0)
            {
                angle.ValueChange(input * -angle.limits.y);
            }
            else if (input < 0)
            {
                angle.ValueChange(Mathf.Abs(input) * -angle.limits.x);
            }
            else if (input == 0)
            {
                if (angle.GetValue() != 0)
                {
                    angle.ValueChange(0);
                }
            }

            obj.transform.localEulerAngles = originalAngle + (axis.normalized * angle.smoothValue);
        }

        public void MoveSurface(float value)
        {
            value = Mathf.Clamp(value, -1, 1);
            input = value;
        }

        public float GetAngle()
        {
            if (axis.x != 0)
            {
                return (axis.normalized * angle.smoothValue).x;
            }
            else if (axis.y != 0)
            {
                return (axis.normalized * angle.smoothValue).y;
            }
            else if (axis.z != 0)
            {
                return (axis.normalized * angle.smoothValue).z;
            }

            return 0;
        }
    }

    [Serializable]
    public class ControlSurfaceOneWay
    {
        public string name;

        public Airfoil airfoil;

        public Transform obj;
        public SmoothFloat angle;
        public Vector3 axis;
        [Range(0, 1)]
        public float input;
        public Vector3 originalAngle;


        public void Init()
        {
            originalAngle = obj.transform.localEulerAngles;
        }

        public void FixedUpdate()
        {
            angle.Update(SmoothFloat.UpdateType.FixedUpdate);

            angle.ValueChange(input * angle.limits.y);

            obj.transform.localEulerAngles = originalAngle + (axis.normalized * angle.smoothValue);
        }

        public void MoveSurface(float value)
        {
            value = Mathf.Clamp01(value);
            input = value;
        }

        public float GetAngle()
        {
            if(axis.x != 0)
            {
                return (axis.normalized * angle.smoothValue).x;
            }
            else if (axis.y != 0)
            {
                return (axis.normalized * angle.smoothValue).y;
            }
            else if (axis.z != 0)
            {
                return (axis.normalized * angle.smoothValue).z;
            }

            return 0;
        }
    }

    [Serializable]
    public class Wing
    {
        public string name;

        public Airfoil airfoil;

        public ControlSurfaceTwoWay aileron;

        public enum SpoilerState { Ground, Speedbrake };
        public SpoilerState spoilerState;
        public ControlSurfaceOneWay[] spoilers;

        public FlapAssembly[] flaps;

        int lastSpoilersSwitch = 0;
        int lastFlapsSwitch = 0;


        [Serializable]
        public class FlapAssembly
        {
            public string name;

            public Transform obj;
            public Transform[] fairings;
            public SmoothFloat flapAngle;
            float realFlapAngle;
            float setFlapAngle;
            float setFlapPosition;
            public float flapMovementSpeed;
            public Vector3 flapAxis;
            public Vector3 flapMovementAxis;
            public float[] rotations = new float[] { 0, 10, 15, 20, 35 };
            public float[] positions = new float[] { 0, 10, 15, 20, 35 };
            public int flapPosition;

            Vector3 originalAngle;
            Vector3 transformAngle;
            Vector3 originalPos;


            public void Init()
            {
                originalAngle = obj.transform.localEulerAngles;
                originalPos = obj.transform.localPosition;

                if (flapMovementAxis.x != 0) { transformAngle = obj.transform.right; } 
                else if(flapMovementAxis.y != 0) { transformAngle = obj.transform.up; }
                else if(flapMovementAxis.z != 0) { transformAngle = obj.transform.forward; }

                flapAngle.limits.x = 0;
                flapAngle.limits.y = rotations[rotations.Length - 1];
            }

            public void FixedUpdate()
            {
                flapAngle.Update(SmoothFloat.UpdateType.FixedUpdate);

                setFlapAngle = rotations[Mathf.Clamp(flapPosition, 0, rotations.Length - 1)];
                setFlapPosition = positions[Mathf.Clamp(flapPosition, 0, positions.Length - 1)];

                if (realFlapAngle < setFlapAngle)
                {
                    realFlapAngle += Mathf.Clamp(flapMovementSpeed * Time.fixedDeltaTime, 0, (setFlapAngle - realFlapAngle) * Time.fixedDeltaTime);
                }
                else if(realFlapAngle > setFlapAngle)
                {
                    realFlapAngle -= Mathf.Clamp(flapMovementSpeed * Time.fixedDeltaTime, 0, (realFlapAngle - setFlapAngle) * Time.fixedDeltaTime);
                }

                flapAngle.ValueChange(realFlapAngle);

                obj.transform.localEulerAngles = originalAngle + (Vector3.ProjectOnPlane(flapAxis, originalAngle.normalized) * flapAngle.smoothValue);
                obj.transform.localPosition = originalPos + (transformAngle.normalized * setFlapPosition);

                Debug.DrawRay(obj.transform.position, Vector3.ProjectOnPlane(flapMovementAxis, (originalAngle - system.transform.eulerAngles).normalized), Color.black);
            }

            public void MoveSurface(int position)
            {
                flapPosition = position;
            }

            public float GetAngle()
            {
                if (flapAxis.x != 0)
                {
                    return (flapAxis.normalized * flapAngle.smoothValue).x;
                }
                else if (flapAxis.y != 0)
                {
                    return (flapAxis.normalized * flapAngle.smoothValue).y;
                }
                else if (flapAxis.z != 0)
                {
                    return (flapAxis.normalized * flapAngle.smoothValue).z;
                }

                return 0;
            }
        }

        public void Init()
        {
            airfoil.Init();

            aileron.Init();

            foreach(ControlSurfaceOneWay spoiler in spoilers)
            {
                spoiler.Init();
            }

            foreach (FlapAssembly flap in flaps)
            {
                flap.Init();
            }

            spoilerState = SpoilerState.Ground;
        }

        public void FixedUpdate(float airDensity, Vector3 relativeVelocity)
        {
            if (system.onGround)
            {
                if (spoilerState != SpoilerState.Ground) spoilerState = SpoilerState.Ground;
            }
            else
            {
                if (spoilerState != SpoilerState.Speedbrake) spoilerState = SpoilerState.Speedbrake;
            }

            float aileronLimitAngle = 1;
            if (aileron.GetAngle() > 0)
            {
                aileronLimitAngle = aileron.angle.limits.y;
            }
            else if (aileron.GetAngle() < 0)
            {
                aileronLimitAngle = aileron.angle.limits.x;
            }

            airfoil.Update(airDensity, Mathf.Sign(aileronLimitAngle) * aileron.deflectionCurve.Evaluate(aileron.GetAngle() / aileronLimitAngle) * aileron.maxSurfaceAoAChange, new int[] { 4 }, relativeVelocity);

            aileron.FixedUpdate();

            foreach (ControlSurfaceOneWay spoiler in spoilers)
            {
                spoiler.FixedUpdate();

                if(lastSpoilersSwitch != system.spoilerSwitch)
                {
                    if(spoilerState == SpoilerState.Ground)
                    {
                        MoveControlSurface(Surface.GroundSpoilers, Mathf.Clamp01((float)system.spoilerSwitch / 2));
                    }
                    else if(spoilerState == SpoilerState.Speedbrake)
                    {
                        MoveControlSurface(Surface.Speedbrakes, Mathf.Clamp01(system.spoilerSwitch));
                    }

                    lastSpoilersSwitch = system.spoilerSwitch;
                }
            }

            foreach (FlapAssembly flap in flaps)
            {
                flap.FixedUpdate();

                if(lastFlapsSwitch != system.flapsSwitch)
                {
                    foreach(FlapAssembly fl in flaps)
                    {
                        fl.MoveSurface(system.flapsSwitch);
                    }

                    lastFlapsSwitch = system.flapsSwitch;
                }
            }
        }

        public enum Surface { Aileron, GroundSpoilers, Speedbrakes };
        public void MoveControlSurface(Surface surface, float value)
        {
            if(surface == Surface.Aileron)
            {
                value = Mathf.Clamp(value, -1, 1);
                aileron.MoveSurface(value);
            }
            else if(surface == Surface.GroundSpoilers)
            {
                value = Mathf.Clamp01(value);

                foreach (ControlSurfaceOneWay spoiler in spoilers)
                {
                    spoiler.MoveSurface(value);
                }
            }
            else if(surface == Surface.Speedbrakes)
            {
                float val = value;
                for(int i = 1; i < spoilers.Length - 1; i++)
                {
                    val = Mathf.Clamp01(value * 25f / spoilers[i].angle.limits.y);

                    if (i == 1)
                    {
                        spoilers[i].MoveSurface(val / 2);
                    }
                    else
                    {
                        spoilers[i].MoveSurface(val);
                    }
                }
            }
        }

        public float GetLoadFactor()
        {
            return airfoil.load;
        }
    }

    [Serializable]
    public class HorizontalStabilizer
    {
        public string name;

        public Transform stabilizerPivot;
        private Vector3 origStabRotation;
        public Vector3 trimAxis;
        public SmoothFloat stabilizerTrim;
        public float stabTrim;
        public float maxTrimSpeed;
        public PIDController trimPID;
        public AnimationCurve trimToStickDeflection;
        public bool autoTrimming = false;

        float trimSpeed;
        float targetNoseAttitude;

        public Airfoil airfoil;

        public ControlSurfaceTwoWay elevator;


        public void Init()
        {
            airfoil.Init();

            elevator.Init();

            stabTrim = 0;
            trimSpeed = 0;

            origStabRotation = stabilizerPivot.transform.localEulerAngles;
        }

        public void FixedUpdate(float airDensity, Vector3 relativeVelocity)
        {
            float elevatorLimitAngle = 1;
            if(elevator.angle.smoothValue > 0)
            {
                elevatorLimitAngle = elevator.angle.limits.y;
            }
            else if(elevator.angle.smoothValue < 0)
            {
                elevatorLimitAngle = elevator.angle.limits.x;
            }

            if(system.groundSpeed > 100)
            {
                if (!autoTrimming)
                {
                    autoTrimming = true;
                }
            }
            else
            {
                if (autoTrimming)
                {
                    autoTrimming = false;
                }
            }

            if (!autoTrimming)
            {
                stabTrim += Mathf.Clamp(stabilizerTrim.smoothValue - stabTrim, -maxTrimSpeed, maxTrimSpeed) * Time.fixedDeltaTime;
            }
            else
            {
                /*
                if (Mathf.Abs(refer.noseAttitudeChange) < 0.2f && pilot.elevatorInput > 0.02f)
                {
                    trimSpeed = Mathf.Clamp(trimPID.GetThrustFactorFixed(refer.noseAttitude - targetNoseAttitude), -maxTrimSpeed, maxTrimSpeed);
                }
                else
                {
                    targetNoseAttitude = refer.noseAttitude;
                    trimSpeed = Mathf.Clamp(-Mathf.Sign(pilot.elevatorInput) * trimToStickDeflection.Evaluate(Mathf.Abs(pilot.elevatorInput)), -maxTrimSpeed, maxTrimSpeed);
                }
                */
                trimSpeed = Mathf.Clamp(trimPID.GetThrustFactorFixed(-pilot.elevatorInput), -maxTrimSpeed, maxTrimSpeed);

                stabTrim += trimSpeed * Time.fixedDeltaTime;
                stabTrim = Mathf.Clamp(stabTrim, stabilizerTrim.limits.x, stabilizerTrim.limits.y);
            }

            airfoil.Update(airDensity, Mathf.Sign(elevatorLimitAngle) * elevator.deflectionCurve.Evaluate(elevator.angle.smoothValue / elevatorLimitAngle) * elevator.maxSurfaceAoAChange, new int[0], relativeVelocity);

            elevator.FixedUpdate();
            stabilizerTrim.Update(SmoothFloat.UpdateType.FixedUpdate);

            stabilizerPivot.transform.localEulerAngles = origStabRotation + (trimAxis.normalized * stabTrim);
        }

        public void SetTrim(float value)
        {
            stabilizerTrim.ValueChange(value);
        }
    }

    [Serializable]
    public class VerticalStabilizer
    {
        public Airfoil airfoil;

        public ControlSurfaceTwoWay rudder;

        public PIDController yawDamper;
        public PIDController damperRatePID;
        public float yawDamperSpeed;
        public float yawDamperStrength;

        public float yawDamperAltitudeToggle;
        public bool toggleFromGroundHit = false;
        public float yawDamperToggleSpeed;

        float requiredDamper;
        bool manualSet;
        float rudderInput;


        public void Init()
        {
            rudder.Init();
        }

        public void FixedUpdate(float airDensity, Vector3 relativeVelocity, float sideSlip, float yawrate)
        {
            float rudderLimitAngle = 1;
            if (rudder.angle.smoothValue > 0)
            {
                rudderLimitAngle = rudder.angle.limits.y;
            }
            else if (rudder.angle.smoothValue < 0)
            {
                rudderLimitAngle = rudder.angle.limits.x;
            }

            airfoil.Update(airDensity, Mathf.Sign(rudderLimitAngle) * rudder.deflectionCurve.Evaluate(rudder.angle.smoothValue / rudderLimitAngle) * rudder.maxSurfaceAoAChange, new int[0], relativeVelocity);

            requiredDamper = Mathf.Clamp(damperRatePID.GetThrustFactorFixed(-sideSlip), -yawDamperSpeed, yawDamperSpeed);
            rudder.MoveSurface(rudderInput + (Mathf.Clamp01(yawDamperStrength - rudderInput) * Mathf.Clamp(yawDamper.GetThrustFactorFixed(yawrate - requiredDamper), -1, 1)));
            //Debug.Log("Total input: " + (rudderInput + (Mathf.Clamp01(yawDamperStrength - rudderInput) * Mathf.Clamp(yawDamper.GetThrustFactorFixed(yawrate - requiredDamper), -1, 1))) + ", required damper: " + requiredDamper + ", yawDamper output: " + Mathf.Clamp(yawDamper.GetThrustFactorFixed(yawrate - requiredDamper), -1, 1));

            rudder.FixedUpdate();
        }

        public void Update(float altitude, bool groundHit)
        {
            if (!manualSet)
            {
                if (!toggleFromGroundHit)
                {
                    if (altitude >= yawDamperAltitudeToggle)
                    {
                        if (yawDamperStrength != 1)
                        {
                            yawDamperStrength += yawDamperToggleSpeed * Time.deltaTime;

                            if (yawDamperStrength > 1)
                            {
                                yawDamperStrength = 1;
                            }
                        }
                    }
                    else
                    {
                        if (yawDamperStrength != 0)
                        {
                            yawDamperStrength -= yawDamperToggleSpeed * Time.deltaTime;

                            if (yawDamperStrength < 0)
                            {
                                yawDamperStrength = 0;
                            }
                        }
                    }
                }
                else
                {
                    if (!groundHit)
                    {
                        if (yawDamperStrength != 1)
                        {
                            yawDamperStrength += yawDamperToggleSpeed * Time.deltaTime;

                            if (yawDamperStrength > 1)
                            {
                                yawDamperStrength = 1;
                            }
                        }
                    }
                    else
                    {
                        if (yawDamperStrength != 0)
                        {
                            yawDamperStrength -= yawDamperToggleSpeed * Time.deltaTime;

                            if (yawDamperStrength < 0)
                            {
                                yawDamperStrength = 0;
                            }
                        }
                    }

                }
            }
        }

        public void SetYawDamperStrength(float strength, bool smooth)
        {
            if (!smooth)
            {
                yawDamperStrength = strength;
            }
            else
            {
                yawDamperStrength += Mathf.Sign(yawDamperStrength - strength) * yawDamperToggleSpeed * Time.deltaTime;
            }

            if (!manualSet)
            {
                manualSet = true;
            }
        }

        public void ResetToAutomatic()
        {
            manualSet = false;
        }

        public void MoveRudder(float value)
        {
            rudderInput = value;
        }
    }


    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        pilot = GetComponent<A320Pilot>();
        system = GetComponent<A320Systems>();
        adb = GameObject.Find("GameBehaviour").GetComponent<AirportDatabase>();
        gb = GameObject.Find("GameBehaviour").GetComponent<GameBehaviour>();

        rb.centerOfMass = centerOfMass.transform.localPosition;

        //rb.useGravity = false;
        //rb.isKinematic = true;

        mCDU.planPage.AddFlightPlan(gb, mCDU.planPage.departureRunwayWaypoint, mCDU.planPage.arrivalRunwayWaypoint, mCDU.planPage.waypointsToFollowCached);
    }

    private IEnumerator Start()
    {
        affectingWeather = gb.GetLocalConditions(trueAltitude, transform.position);

        pivotPoint = posPoints.Find("pivot_point");
        frontPoint = posPoints.Find("front_gear");

        batteriesOn = false;
        powerMode = PowerMode.Internal;

        foreach(Engine eng in engines)
        {
            eng.Init(affectingWeather.airDensity, fuselageSpeed, machSpeed, affectingWeather.temperatureK, affectingWeather.absolutePressure_hPa * 100);
        }

        foreach(MainGear mng in mainGear)
        {
            mng.Init(skidmark);
        }

        frontGear.Init(skidmark);

        taxiLight.Init();
        takeoffLight.Init();
        turnoffLights.Init();
        beaconLight.Init();
        navLight.Init();
        strobeLight.Init();
        landLight.Init();
        
        foreach(LandLightComponent lnd in landLightObject)
        {
            lnd.Init();
        }

        foreach (Wing wing in wings)
        {
            wing.Init();
        }

        foreach (HorizontalStabilizer hs in horizontalStabilizers)
        {
            hs.Init();
        }

        apu.Init();

        verticalStabilizer.Init();

        autopilot.Init(gb, adb);


        if (startEnginesRunning)
        {
            BatteriesSwitch(true);

            foreach(Engine eng in engines)
            {
                eng.engineSound.fadeIn = true;
                eng.N1rpm.SetRawValue(eng.idleN1rpm);
                eng.N2rpm.SetRawValue(eng.idleN2rpm);
                eng.firstStartup = false;
                eng.ready = true;
                eng.state = 2;
            }

            PowerTransfer(PowerMode.Engine);

            pilot.batteriesOn.isOn = true;
            pilot.eng1Main.isOn = true;
            pilot.eng2Main.isOn = true;

            engines[0].soundRefEngine = true;

            LightSwitch(true, A320Systems.LightType.Beacon);
        }

        realAltimeterSetting.SetRawValue(altimeterSetting);

        tireSkidSound.Init(gb, transform, false);

        yield return new WaitForSeconds(0.5f);
        rb.useGravity = true;
        rb.isKinematic = false;
    }

    private void Update()
    {
        onGroundTest = false;
        mainOnGroundTest = false;
        frontOnGroundTest = false;

        Vector3 origin = Vector3.zero;
        foreach (Engine eng in engines)
        {
            origin += eng.soundPoint.transform.position;
        }
        origin /= 2;

        engineSoundPosition = origin;
        foreach (Engine eng in engines)
        { 
            engineSoundPosition += (origin - eng.soundPoint.transform.position) * eng.engineSound.strength;
        }

        foreach(Engine eng in engines)
        {
            eng.Update(pilot.throttle, engineSoundPosition);
        }

        foreach (MainGear mng in mainGear)
        {
            mng.Update();

            if (mng.onGround)
            {
                onGroundTest = true;
                mainOnGroundTest = true;
            }
        }

        verticalStabilizer.Update(trueAltitude, onGround);

        frontGear.Update();

        if (frontGear.onGround)
        {
            onGroundTest = true;
            frontOnGroundTest = true;
        }

        if (onGroundTest != onGround) { onGroundTimer -= Time.deltaTime; }
        else { onGroundTimer = 1.5f; }

        if (mainOnGroundTest != mainOnGround) { mainOnGroundTimer -= Time.deltaTime; }
        else { mainOnGroundTimer = 1.5f; }

        if (frontOnGroundTest != frontOnGround) { frontOnGroundTimer -= Time.deltaTime; }
        else { frontOnGroundTimer = 1.5f; }

        if (onGroundTimer <= 0) onGround = onGroundTest;
        if (mainOnGroundTimer <= 0) mainOnGround = mainOnGroundTest;
        if (frontOnGroundTimer <= 0) frontOnGround = frontOnGroundTest;

        taxiLight.Update(powerSupply.smoothValue);
        takeoffLight.Update(powerSupply.smoothValue);
        turnoffLights.Update(powerSupply.smoothValue);
        beaconLight.Update(powerSupply.smoothValue);
        navLight.Update(powerSupply.smoothValue);
        strobeLight.Update(powerSupply.smoothValue);
        landLight.Update(powerSupply.smoothValue);

        foreach (LandLightComponent lnd in landLightObject)
        {
            lnd.Update();
        }

        apu.Update();

        powerSupply.Update(SmoothFloat.UpdateType.Update);

        anyEnginesReady = false;
        foreach(Engine eng in engines)
        {
            if (eng.ready)
            {
                anyEnginesReady = true;
            }
        }

        if(apu.apuReady && !anyEnginesReady && powerMode != PowerMode.APU)
        {
            PowerTransfer(PowerMode.APU);
        }

        if (anyEnginesReady && powerMode != PowerMode.Engine)
        {
            PowerTransfer(PowerMode.Engine);
        }

        if(!apu.apuReady && !anyEnginesReady && powerMode != PowerMode.Internal)
        {
            PowerTransfer(PowerMode.Internal);
        }

        realAltimeterSetting.Update(SmoothFloat.UpdateType.Update);

        totalTireSlip = 0;
        foreach(Wheel wh in frontGear.wheels)
        {
            totalTireSlip += wh.realSlip;
        }
        foreach (MainGear mng in mainGear)
        {
            foreach (Wheel wh in mng.wheels)
            {
                wh.commandedBrake = wheelBrake;
                totalTireSlip += wh.realSlip;
            }
        }

        tireSkidSound.StrengthChange(tireSkidVolumeCurve.Evaluate(totalTireSlip / (tireSkidLimit * 6)));
        tireSkidSound.PitchChange(tireSkidPitchCurve.Evaluate(totalTireSlip / (tireSkidLimit * 6)));

        if(groundSpeed <= minAntiSkidSpeed)
        {
            if (antiSkid) antiSkid = false;
        }
        else
        {
            if (!antiSkid) antiSkid = true;
        }

        mCDU.planPage.Update();
    }

    private void FixedUpdate()
    {
        vector2Pos = new Vector2(transform.position.x, transform.position.z);
        pivotPointV2 = new Vector2(pivotPoint.transform.position.x, pivotPoint.transform.position.z);
        frontPointV2 = new Vector2(frontPoint.transform.position.x, frontPoint.transform.position.z);

        autopilot.Update();

        smoothForwardAcceleration.Update(SmoothFloat.UpdateType.FixedUpdate);

        affectingWeather = gb.GetLocalConditions(trueAltitude, transform.position);

        relativeVelocity = rb.velocity + new Vector3(affectingWeather.windVelocity.x, 0, affectingWeather.windVelocity.y);
        correctedRelativeVelocity = rb.velocity + new Vector3(affectingWeather.cleanWindVelocity.x, 0, affectingWeather.cleanWindVelocity.y);

        fuselageSpeed = relativeVelocity.magnitude;
        fuselageVelocity = relativeVelocity;

        Vector3 localangularvelocity = transform.InverseTransformDirection(rb.angularVelocity);
        forwardAcceleration = CalculateForwardAcceleration();
        smoothForwardAcceleration.ValueChange(forwardAcceleration);
        turnrate = CalculateTurnrate();
        noseAttitudeChange = -localangularvelocity.x / Time.fixedDeltaTime;
        rollSpeed = -localangularvelocity.z / Time.fixedDeltaTime;
        yawrate = -localangularvelocity.y / Time.fixedDeltaTime;

        rb.mass = emptyWeight + payload + (pax * passengerAverageWeight) + (fobLiters * 0.8f);

        trueFlightPathAngle = noseAttitude - fuselageAngleOfAttack;

        oncomingFlow.Update(affectingWeather.windDirection, affectingWeather.windSpeed);

        machSpeed = groundSpeed / (affectingWeather.speedOfSound * metersToKnots);

        groundSpeed = new Vector3(rb.velocity.x, 0, rb.velocity.z).magnitude * metersToKnots;
        equivalentAirspeed = 661.47f * machSpeed * Mathf.Sqrt(affectingWeather.absolutePressure_hPa / gb.standardPressure_hPa);
        indicatedAirspeed = equivalentAirspeed + oncomingFlow.GetOncomingFlow(affectingWeather, modifiedSin).velocity;
        cleanAirspeed = equivalentAirspeed + oncomingFlow.GetCleanOncomingFlow(affectingWeather, modifiedSin).velocity;
        trueAirspeed = (machSpeed * (metersToKnots * affectingWeather.speedOfSound)) + oncomingFlow.GetOncomingFlow(affectingWeather, modifiedSin).velocity;
        trueAltitude = rb.transform.localPosition.y * metersToFeet;
        rateOfClimb = rb.velocity.y * metersToFeet * 60f;

        CalculateAverageAirspeed();

        Vector3 localVelocity = transform.InverseTransformDirection(relativeVelocity);
        Vector3 localVelocityCorrect = transform.InverseTransformDirection(correctedRelativeVelocity);
        float alpha = Mathf.Atan2(-localVelocity.y, localVelocity.z);
        float alphaSide = Mathf.Atan2(localVelocity.x, localVelocity.z);
        float alphaSideCorrect = Mathf.Atan2(localVelocityCorrect.x, localVelocityCorrect.z);

        fuselageAngleOfAttack = (alpha * Mathf.Rad2Deg);
        fuselageSideSlip = (alphaSide * Mathf.Rad2Deg);
        correctedSideSlip = (alphaSideCorrect * Mathf.Rad2Deg);

        noseAttitude = transform.localEulerAngles.x;
        noseAttitude = -((noseAttitude > 180) ? noseAttitude - 360 : noseAttitude);
        rollAngle = transform.localEulerAngles.z;
        rollAngle = -((rollAngle > 180) ? rollAngle - 360 : rollAngle);

        heading = transform.eulerAngles.y;
        Vector3 normalizedVelocity = new Vector3(rb.velocity.x, 0, -rb.velocity.z).normalized;
        track = Mathf.PI + -Mathf.Atan2(normalizedVelocity.x, normalizedVelocity.z);

        airframeLoadFactor = 0;
        totalAirframeDrag = 0;
        totalAirframeLift = 0;
        foreach (Wing wing in wings)
        {
            wing.FixedUpdate(affectingWeather.airDensity, relativeVelocity);
            airframeLoadFactor += wing.GetLoadFactor();
            totalAirframeDrag += wing.airfoil.airfoilDrag;
            totalAirframeLift += wing.airfoil.airfoilLift;
        }

        Debug.DrawRay(transform.position, transform.forward * 100, Color.black);
        Debug.DrawRay(transform.position, rb.velocity.normalized * 100, Color.red);

        RaycastHit hit;
        if (Physics.Raycast(radioAltimeterLocation.transform.position, Vector3.down, out hit, (maxRadioAltimeterDistance / metersToFeet), radioAltimeterMask))
        {
            radioAltimeter = (hit.distance * metersToFeet) - radioAltimeterHeightError;

            Debug.DrawLine(radioAltimeterLocation.transform.position, radioAltimeterLocation.transform.position + (Vector3.down * hit.distance), Color.yellow);
        }
        else
        {
            radioAltimeter = 0;
        }

        if (altimeterMode == AltimeterSetting.pressure)
        {
            if(realAltimeterSetting.GetValue() != altimeterSetting)
            {
                realAltimeterSetting.ValueChange(altimeterSetting);
            }
        }
        else
        {
            if(realAltimeterSetting.GetValue() != gb.standardPressure_hPa)
            {
                realAltimeterSetting.ValueChange(gb.standardPressure_hPa);
            }
        }

        indicatedAltitude = (((Mathf.Pow(realAltimeterSetting.smoothValue / affectingWeather.absolutePressure_hPa, 1 / 5.257f) - 1) * affectingWeather.temperatureK) / 0.0065f) * metersToFeet;
        currentFlightLevel = (int)(indicatedAltitude / 100);

        foreach (MainGear mng in mainGear)
        {
            mng.FixedUpdate(antiSkid);
        }

        frontGear.FixedUpdate();

        totalEngineThrust = 0;
        foreach(Engine eng in engines)
        {
            eng.FixedUpdate(affectingWeather.airDensity, fuselageSpeed, machSpeed, affectingWeather.temperatureK, affectingWeather.absolutePressure_hPa * 100);
            totalEngineThrust += eng.totalThrust;
        }

        foreach (HorizontalStabilizer hs in horizontalStabilizers)
        {
            hs.FixedUpdate(affectingWeather.airDensity, relativeVelocity);
            totalAirframeDrag += hs.airfoil.airfoilDrag;
            totalAirframeLift += hs.airfoil.airfoilLift;
        }

        verticalStabilizer.FixedUpdate(affectingWeather.airDensity, relativeVelocity, correctedSideSlip, yawrate);
        totalAirframeDrag += verticalStabilizer.airfoil.airfoilDrag;
        totalAirframeLift += verticalStabilizer.airfoil.airfoilLift;

        coordinatePosition.Update(transform.position, gb);

        maxCurrentClimbSpeed = (fuselageSpeed * ((totalEngineThrust - totalAirframeDrag) / (rb.mass * Mathf.Abs(Physics.gravity.y)))) * metersToFeet * 60f;
    }


    public int GetEngineState(Side side)
    {
        if(side == Side.Left)
        {
            return engines[1].state;
        }
        else if(side == Side.Right)
        {
            return engines[0].state;
        }

        return 0;
    }

    public void AileronRollInput(float value)
    {
        foreach(Wing wing in wings)
        {
            wing.MoveControlSurface(Wing.Surface.Aileron, value);
        }
    }

    public void AileronPitchInput(float value)
    {
        foreach (HorizontalStabilizer hs in horizontalStabilizers)
        {
            hs.elevator.MoveSurface(value);
        }
    }

    public void RudderYawInput(float value)
    {
        verticalStabilizer.MoveRudder(value);
    }

    public void SteeringInput(float value)
    {
        frontGear.SetSteering(value, steerMode, groundSpeed);

        if (steerMode == SteerMode.Stabilizer)
        {
            RudderYawInput(value);
        }
        else if(steerMode == SteerMode.NoseWheel)
        {
            if(verticalStabilizer.rudder.angle.GetValue() != 0)
            {
                RudderYawInput(0);
            }
        }
    }

    public void WheelBrakingInput(float input)
    {
        wheelBrake = Mathf.Clamp01(input);
    }

    public void ToggleSteeringMode()
    {
        if(steerMode == SteerMode.NoseWheel)
        {
            steerMode = SteerMode.Stabilizer;
        }
        else if(steerMode == SteerMode.Stabilizer)
        {
            steerMode = SteerMode.NoseWheel;
        }
    }

    public void SetSteeringMode(SteerMode mode)
    {
        steerMode = mode;
    }

    private IEnumerator GearUp()
    {
        gearRetracting = true;

        StartCoroutine(frontGear.GearUp());
        foreach(MainGear mng in mainGear)
        {
            StartCoroutine(mng.GearUp());
        }

        yield return new WaitUntil(() => frontGear.currentState == 0);
        yield return new WaitUntil(() => mainGear[0].currentState == 0);

        gearRetracting = false;
        gearDown = false;
    }

    private IEnumerator GearDown()
    {
        gearRetracting = true;

        StartCoroutine(frontGear.GearDown());
        foreach (MainGear mng in mainGear)
        {
            StartCoroutine(mng.GearDown());
        }

        yield return new WaitUntil(() => frontGear.currentState == 3);
        yield return new WaitUntil(() => mainGear[0].currentState == 3);

        gearRetracting = false;
        gearDown = true;
    }

    public void ToggleGearState()
    {
        if (!gearRetracting)
        {
            if (gearDown)
            {
                StartCoroutine(GearUp());
            }
            else
            {
                StartCoroutine(GearDown());
            }
        }
    }

    public void SetGearState(bool state)
    {
        if (!gearRetracting)
        {
            if (state)
            {
                if (!gearDown)
                {
                    StartCoroutine(GearDown());
                }
            }
            else
            {
                if (gearDown)
                {
                    StartCoroutine(GearUp());
                }
            }
        }
    }

    public float ShortestAngle(float start, float target)
    {
        float modDiff = (target - start) % (Mathf.PI * 2);
        float shortestDistance = Mathf.PI - Mathf.Abs(Mathf.Abs(modDiff) - Mathf.PI);
        return (modDiff + (Mathf.PI * 2)) % (Mathf.PI * 2) < Mathf.PI ? shortestDistance *= 1 : shortestDistance *= -1;
    }

    public void LightSwitch(bool state, LightType light)
    {
        if(light == LightType.Taxi)
        {
            if (!state && takeoffLightOn)
            {
                LightSwitch(false, LightType.Takeoff);
            }

            taxiLight.SwitchState(Convert.ToInt32(state));

            taxiLightOn = state;
        }
        else if(light == LightType.Takeoff)
        {
            if (!taxiLightOn)
            {
                LightSwitch(true, LightType.Taxi);
            }

            takeoffLight.SwitchState(Convert.ToInt32(state));

            takeoffLightOn = state;
        }
        else if(light == LightType.Turnoff)
        {
            turnoffLights.SwitchState(Convert.ToInt32(state));

            turnoffLightsOn = state;
        }
        else if(light == LightType.Beacon)
        {
            beaconLight.SwitchState(Convert.ToInt32(state));

            beaconLightOn = state;
        }
        else if(light == LightType.Nav)
        {
            navLight.SwitchState(Convert.ToInt32(state));

            navLightOn = state;
        }
        else if (light == LightType.Strobe)
        {
            strobeLight.SwitchState(Convert.ToInt32(state));

            strobeLightOn = state;
        }
        else if (light == LightType.Land)
        {
            if (batteriesOn)
            {
                StartCoroutine(LandLightSwitchIE(state));
            }
        }
    }

    private IEnumerator LandLightSwitchIE(bool state)
    {
        if (!state)
        {
            landLight.SwitchState(Convert.ToInt32(state));
        }

        foreach (LandLightComponent lnd in landLightObject)
        {
            lnd.SwitchState(Convert.ToInt32(state));
        }

        if(state)
        {
            yield return new WaitUntil(() => landLightObject[0].state == 3);
        }
        else if(!state)
        {
            yield return new WaitUntil(() => landLightObject[0].state == 0);
        }

        if (state)
        {
            landLight.SwitchState(Convert.ToInt32(state));
        }

        landLightOn = state;
    }

    public void APUStateSwitch(bool state)
    {
        if (state)
        {
            StartCoroutine(apu.Startup(batteriesOn));
        }
        else
        {
            StartCoroutine(apu.Shutdown());
        }
    }

    private void PowerTransfer(PowerMode mode)
    {
        StartCoroutine(PowerTransferIE(mode));
    }

    public void BatteriesSwitch(bool state)
    {
        batteriesOn = state;
        powerSupply.ValueChange(Convert.ToInt32(state));

        if (state)
        {
            PowerTransfer(PowerMode.Internal);
        }
    }

    public void EngineStart(Side side)
    {
        if(side == Side.Left)
        {
            StartCoroutine(engines[1].Startup(apu.apuBleed));
        }
        else if(side == Side.Right)
        {
            StartCoroutine(engines[0].Startup(apu.apuBleed));
        }
    }

    public void EngineShutdown(Side side)
    {
        if (side == Side.Left)
        {
            StartCoroutine(engines[1].Shutdown());
        }
        else if (side == Side.Right)
        {
            StartCoroutine(engines[0].Shutdown());
        }
    }

    private IEnumerator PowerTransferIE(PowerMode mode)
    {
        powerSupply.ValueChange(0);
        powerMode = PowerMode.Internal;

        yield return new WaitForSeconds(0.13f);

        powerMode = mode;
        powerSupply.ValueChange(1);
    }

    public float GetCurrentAircraftWeight()
    {
        return rb.mass;
    }

    float CalculateForwardAcceleration()
    {
        float newVelocity = groundSpeed;
        float acceleration = (newVelocity - oldVelocity) / Time.fixedDeltaTime;
        oldVelocity = newVelocity;
        return acceleration;
    }

    float CalculateTurnrate()
    {
        float newRate = track;
        float acceleration = (ShortestAngle(newRate, oldTurnrate) * Mathf.Rad2Deg) / Time.fixedDeltaTime;
        oldTurnrate = newRate;
        return -acceleration;
    }

    void CalculateAverageAirspeed()
    {
        if (averageAirspeedTimer <= 0)
        {
            indicatedAirSpeedList.Add(indicatedAirspeed);

            if (indicatedAirSpeedList.Count > averageAirspeedTime * averageAirspeedFrequency)
            {
                indicatedAirSpeedList.RemoveAt(0);
            }

            averageAirspeedTimer = 1 / averageAirspeedFrequency;
        }

        averageAirspeedTimer -= Time.fixedDeltaTime;

        indicatedAirspeedAverage = 0;
        foreach (float st in indicatedAirSpeedList)
        {
            indicatedAirspeedAverage += st;
        }
        indicatedAirspeedAverage /= averageAirspeedTime * averageAirspeedFrequency;
    }

    public float GetStandardAltitude()
    {
        return (((Mathf.Pow(gb.standardPressure_hPa / affectingWeather.absolutePressure_hPa, 1 / 5.257f) - 1) * affectingWeather.temperatureK) / 0.0065f) * metersToFeet;
    }

    public void SetSpoilerSwitch(int state)
    {
        spoilerSwitch = Mathf.Clamp(state, -1, 2);
    }

    public void SetFlapsSwitch(int state)
    {
        flapsSwitch = Mathf.Clamp(state, 0, 4);
    }

    private void OnDrawGizmos()
    {
        for (int s = 0; s < mCDU.planPage.segments.Count; s++)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].pc.x, transform.position.y, mCDU.planPage.segments[s].pc.z), new Vector3(mCDU.planPage.segments[s].c1.x, transform.position.y, mCDU.planPage.segments[s].c1.z));
            Gizmos.color = Color.red;
            Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].pc.x, transform.position.y, mCDU.planPage.segments[s].pc.z), new Vector3(mCDU.planPage.segments[s].c2.x, transform.position.y, mCDU.planPage.segments[s].c2.z));

            Gizmos.color = Color.green;
            Gizmos.DrawSphere(new Vector3(mCDU.planPage.segments[s].pc.x, transform.position.y, mCDU.planPage.segments[s].pc.z), 50);

            if (s == 0)
            {
                if (mCDU.planPage.segments.Count == 1)
                {
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].fromPos.x, transform.position.y, mCDU.planPage.segments[s].fromPos.z), new Vector3(mCDU.planPage.segments[s].c1.x, transform.position.y, mCDU.planPage.segments[s].c1.z));
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].c2.x, transform.position.y, mCDU.planPage.segments[s].c2.z), new Vector3(mCDU.planPage.segments[s].toPos.x, transform.position.y, mCDU.planPage.segments[s].toPos.z));
                }
                else if (mCDU.planPage.segments.Count > 1)
                {
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].fromPos.x, transform.position.y, mCDU.planPage.segments[s].fromPos.z), new Vector3(mCDU.planPage.segments[s].c1.x, transform.position.y, mCDU.planPage.segments[s].c1.z));
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].c2.x, transform.position.y, mCDU.planPage.segments[s].c2.z), new Vector3(mCDU.planPage.segments[s + 1].c1.x, transform.position.y, mCDU.planPage.segments[s + 1].c1.z));
                }
            }
            else if (s > 0 && s < mCDU.planPage.segments.Count - 1)
            {
                Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].c2.x, transform.position.y, mCDU.planPage.segments[s].c2.z), new Vector3(mCDU.planPage.segments[s + 1].c1.x, transform.position.y, mCDU.planPage.segments[s + 1].c1.z));
            }
            else if (s == mCDU.planPage.segments.Count - 1)
            {
                Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].c2.x, transform.position.y, mCDU.planPage.segments[s].c2.z), new Vector3(mCDU.planPage.segments[s].toPos.x, transform.position.y, mCDU.planPage.segments[s].toPos.z));
            }

            for (int x = 0; x < mCDU.planPage.segments[s].turnPoints.Length; x++)
            {
                if (x < mCDU.planPage.segments[s].turnPoints.Length - 1)
                {
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.segments[s].turnPoints[x].x, transform.position.y, mCDU.planPage.segments[s].turnPoints[x].z), new Vector3(mCDU.planPage.segments[s].turnPoints[x + 1].x, transform.position.y, mCDU.planPage.segments[s].turnPoints[x + 1].z));
                }
            }
        }

        for (int g = 0; g < mCDU.planPage.waypoints.Count; g++)
        {
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(new Vector3(mCDU.planPage.waypoints[g].waypoint.position.x, transform.position.y, mCDU.planPage.waypoints[g].waypoint.position.z), 50);
            Gizmos.color = Color.red;
            Gizmos.DrawRay(new Vector3(mCDU.planPage.waypoints[g].waypoint.position.x, transform.position.y, mCDU.planPage.waypoints[g].waypoint.position.z), mCDU.planPage.waypoints[g].pointDirection * 1500);
            if(g > 0)
            {
                if (mCDU.planPage.waypoints[g].connectedSegment != null)
                {
                    Gizmos.color = Color.yellow;
                    Gizmos.DrawLine(new Vector3(mCDU.planPage.waypoints[g].waypoint.position.x, transform.position.y, mCDU.planPage.waypoints[g].waypoint.position.z), new Vector3(mCDU.planPage.waypoints[g].connectedSegment.c1.x, transform.position.y, mCDU.planPage.waypoints[g].connectedSegment.c1.z));
                }
            }
        }

        Gizmos.color = Color.red;
        Vector3 descentPoint = mCDU.planPage.GetDescentPoint(mCDU, mCDU.initPage.cruiseFL);
        Gizmos.DrawWireSphere(new Vector3(descentPoint.x, transform.position.y, descentPoint.z), 50);
    }
}
